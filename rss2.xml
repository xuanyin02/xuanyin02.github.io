<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>宣胤星球</title>
    <link>http://xuanyin02.github.io/</link>
    
    <atom:link href="http://xuanyin02.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>人生总是充满遗憾，学会在遗憾中成长</description>
    <pubDate>Tue, 20 Jun 2023 16:00:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>神经网络与深度学习基础</title>
      <link>http://xuanyin02.github.io/2023/061444686.html</link>
      <guid>http://xuanyin02.github.io/2023/061444686.html</guid>
      <pubDate>Wed, 14 Jun 2023 02:49:42 GMT</pubDate>
      
      <description>记录了对神经网络与深度学习的基础知识的学习，不仅是对知识的复习，也是知识的分享</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="神经网络与深度学习导论"><a href="#神经网络与深度学习导论" class="headerlink" title="神经网络与深度学习导论"></a>神经网络与深度学习导论</h2><h3 id="人工神经网络发展史"><a href="#人工神经网络发展史" class="headerlink" title="人工神经网络发展史"></a>人工神经网络发展史</h3><h4 id="人工智能、机器学习、深度学习之间的关系"><a href="#人工智能、机器学习、深度学习之间的关系" class="headerlink" title="人工智能、机器学习、深度学习之间的关系"></a>人工智能、机器学习、深度学习之间的关系<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614110838619.png" alt="image-20230614110838619" style="zoom:50%;"><figcaption>image-20230614110838619</figcaption></figure></h4><p>人工智能：计算机科学的一个分支<br>它是研究、开发用于<strong>模拟、延伸和扩展人的智能的理论、方法、技术及应用系统</strong>的一门新的技术科学</p><p>机器学习：一种<strong>实现人工智能</strong>的方法<br>机器学习是一门<strong>多领域交叉学科</strong>，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门<strong>研究计算机怎样模拟或实现人类的学习行为</strong>，以<strong>获取</strong>新的知识或技能，重新组织已有的知识结构使之<strong>不断改善自身</strong>的性能</p><p>深度学习：一种<strong>实现机器学习</strong>的技术<br>深度学习是机器学习领域中一个新的研究方向，<strong>学习样本数据的内在规律和表示层次</strong>。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据</p><h4 id="人工智能门派"><a href="#人工智能门派" class="headerlink" title="人工智能门派"></a>人工智能门派</h4><p>“<strong>符号主义</strong>”，又称逻辑主义、计算机学派，主张用公理和逻辑体系搭建一套人工智能系统</p><p>“<strong>连接主义</strong>”，又称仿生学派，主张模仿人类的神经元，用神经网络的连接机制实现人工智能</p><p>在<strong>符号主义者</strong>的眼里，人工智能应该模仿人类的逻辑方式获取知识，而<strong>连接主义者</strong>奉行大数据和训练学习知识</p><h4 id="人工神经网络发展的不同时期"><a href="#人工神经网络发展的不同时期" class="headerlink" title="人工神经网络发展的不同时期"></a>人工神经网络发展的不同时期</h4><p>萌芽期：19世纪，众多生理学家和心理学家已开始进行动物实验，尝试通过观察动物的行为模式，分析智能行为实现的原理<br>通过实验得出，动物会在每次尝试中，构建一种刺激-反应联系，当它们成功时，就会记下这些刺激-反应，那些不正确的就会慢慢被排除掉，也就是说<strong>学习的实质是不断的形成刺激-反应的过程</strong></p><p>孕育期：<br><strong>1943年</strong>，心理学家<strong>Warren McCulloch</strong>和数理逻辑学家<strong>Walter Pitts</strong>在合作的论文中<strong>提出了人工神经网络的概念及人工神经元的数学模型（M-P模型）</strong>，从而开创了人工神经网络研究的时代</p><p><strong>1949年</strong>，心理学家<strong>Donald Olding Hebb</strong>根据神经可塑性的机制在论文中描述了<strong>神经元学习法则</strong>，并提出了一种学习假说，Hebb的假说后来被成为<strong>赫布型学习</strong>，被认为是一种典型的<strong>无监督学习规则</strong></p><p><strong>1957年</strong>，<strong>Frank Rosenblatt</strong>教授提出了<strong>感知机模型（Perceptron）</strong>。感知机使用<strong>特征向量</strong>来表示的<strong>前馈式人工神经网络</strong>，它是一种<strong>二元分类器</strong>，在人工神经网络领域中，感知机也被指为<strong>单层的人工神经网络</strong></p><p>达特茅斯会议：<strong>1956年</strong>，一个崭新的学科–<strong>人工智能</strong>，从达特茅斯会议开启</p><p>寒冬：<br><strong>1969年</strong>，<strong>Marvin Minsky</strong> 和 <strong>Seymour Papert</strong>在《Perceptrons》一书中，仔细分析了以感知机为代表的单层神经网络系统的功能及局限。证明了感知机的两大缺陷：其一，无法处理<strong>异或问题</strong>；其二，当时计算机的<strong>计算能力不足</strong>以处理大型神经网络。<strong>Marvin Minsky</strong>教授甚至做出了“基于感知机的研究注定失败”的结论</p><p>由于<strong>Rosenblatt</strong>教授等人没能及时推广感知机学习算法到多层神经网络上，又由于《Perceptrons》在研究领域中的巨大影响，及人们对书中论点的误解，造成了人工神经领域发展的长年停滞及低潮，<strong>之后的十多年内，基于神经网络的研究几乎处于停滞状态</strong></p><p>误差反向传播算法：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614131156046.png" alt="image-20230614131156046"><figcaption>image-20230614131156046</figcaption></figure><br><strong>1974年</strong>，BP算法首次提出：<strong>Paul Werbos</strong>在博士论文中提出了用**误差反向传导（BP)**来训练人工神经网络，有效解决了异或回路问题，使得训练多层神经网络成为可能。但是当时正值神经网络低潮期，并未受到应有的重视</p><p><strong>1983年</strong>，神经网络的应用：物理学家<strong>John Hopfield</strong>利用<strong>神经网络</strong>，在旅行商这个<strong>NP</strong>问题的求解上获得当时最好成绩，引起了轰动</p><p><strong>1986年</strong>，BP算法改进与应用：<strong>Hinton</strong>等人将重新改进的<strong>反向传播算法</strong>引入<strong>多层感知机</strong>，神经网络重新成为热点。反向传播算法是神经网络中极为重要的学习算法，<strong>直到现在仍然占据着重要地位</strong></p><p>寒冬中的寒冬：<strong>1995年</strong>，<strong>万普尼克</strong>正式提出了统计学学习理论，并将该方法应用到了<strong>SVM</strong>。支持向量机可以免去神经网络需要调节参数的不足，还避免了神经网络中局部最优问题，一举击败神经网络，称为当时人工智能领域的主流算法，使得<strong>神经网络再受沉重打击</strong></p><p>LeNet-5模型：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614132108765.png" alt="image-20230614132108765"><figcaption>image-20230614132108765</figcaption></figure><br><strong>1998年</strong>，计算机科学家<strong>Yann LeCun</strong>等提出的<strong>LeNet-5</strong>采用了<strong>基于梯度的反向传播算法</strong>对网络进行<strong>有监督</strong>的训练，主要进行手写数字识别和英文字母识别。LeNet-5网络虽然很小，但是它<strong>包含了后来被称为“深度学习”的基本模块：卷积层，池化层，全连接层</strong>，是其他深度学习模型的基础</p><p>春天：随着<strong>GPU、FPGA</strong>等器件被用于<strong>高性能计算</strong>，使得人们可以通过单纯地增加器件数量来提升神经网络训练学习的速度。<strong>大数据</strong>的出现，使得训练深层网络模型所需要的数据难题得以大幅度缓解。从此，<strong>神经网络成为人工智能领域最热门的研究方向</strong></p><p>深度学习：<strong>2006年</strong>，<strong>Hinton</strong>提出了<strong>深度置信网络（DBN）</strong>，一种深层网络模型。使用一种贪心无监督训练方法来解决问题并取得良好结果。DBN的训练方法降低了学习隐藏层参数的难度，并且该算法的训练时间和网络的大小和深度近乎线性关系</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614120024102.png" alt="image-20230614120024102"><figcaption>image-20230614120024102</figcaption></figure></p><p>当前常见深度学习框架</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614120127480.png" alt="image-20230614120127480"><figcaption>image-20230614120127480</figcaption></figure></p><h3 id="神经网络结构基础"><a href="#神经网络结构基础" class="headerlink" title="神经网络结构基础"></a>神经网络结构基础</h3><h4 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614201025232.png" alt="image-20230614201025232"><figcaption>image-20230614201025232</figcaption></figure></p><h4 id="神经网络如何学习"><a href="#神经网络如何学习" class="headerlink" title="神经网络如何学习"></a>神经网络如何学习</h4><p>赫布法则：当神经元A的一个轴突和神经元B很近，足以对它产生影响，并且持续地、重复地参与了神经元B的兴奋，那么在这两个神经元或其中之一会发生某种生长过程或新城代谢变化，以致于神经元A作为能使神经元B兴奋的细胞之一，它的效能加强了–加拿大心理学家Donald Hebb</p><h4 id="生物神经网络"><a href="#生物神经网络" class="headerlink" title="生物神经网络"></a>生物神经网络</h4><p>在机器学习和相关领域，<strong>人工神经网络</strong>的计算模型灵感正是来自<strong>生物神经网络</strong>：每个神经元与其他神经元<strong>相连</strong>，当它<strong>兴奋</strong>时，就会向相邻的神经元<strong>发送</strong>化学物质，从而改变这些神经元内的电位。<br>如果某神经元的电位超过了一个阈值，那么它就会被<strong>激活（兴奋）</strong>，向其他神经元发送化学物质。</p><p><strong>人工神经网络</strong>通常呈现为按照一定的层次结构连接起来的“神经元”，它可以从输入的计算值，进行<strong>分布式并行</strong>信息处理的算法数学模型。这种网络依靠系统的<strong>复杂程度</strong>，通过<strong>调整</strong>内部大量节点之间相互<strong>连接的关系</strong>，从而达到处理信息的目的。</p><p>常被用于估计或可以依赖于<strong>大量的输入</strong>和一般的<strong>未知近似函数</strong>，来最大化的<strong>拟合</strong>现实中的实际数据，提高<strong>机器学习预测的精度</strong>。</p><h4 id="从生物神经元到人工神经元模型（M-P模型）"><a href="#从生物神经元到人工神经元模型（M-P模型）" class="headerlink" title="从生物神经元到人工神经元模型（M-P模型）"></a>从生物神经元到人工神经元模型（M-P模型）</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614202430527.png" alt="image-20230614202430527"><figcaption>image-20230614202430527</figcaption></figure></p><p>人工神经元：</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614202500173.png" alt="image-20230614202500173" style="zoom: 25%;"><figcaption>image-20230614202500173</figcaption></figure><p>激活函数的性质：</p><ul><li>连续并可导（允许少数点上不可导）的非线性函数。可导的激活函数可以直接利用数值优化的方法来学习网络参数</li><li>激活函数及其导函数要尽可能的简单，有利于提高网络计算效率</li><li>激活函数的导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和稳定性</li></ul><p>常见激活函数及其导数：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614203106650.png" alt="image-20230614203106650"><figcaption>image-20230614203106650</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614203119416.png" alt="image-20230614203119416"><figcaption>image-20230614203119416</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614203129561.png" alt="image-20230614203129561"><figcaption>image-20230614203129561</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614203204431.png" alt="image-20230614203204431"><figcaption>image-20230614203204431</figcaption></figure></p><h4 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h4><p>人工神经网络主要由大量的神经元以及它们之间的有向连接构成。因此考虑三方面：</p><ol><li>神经元的激活规则：主要指神经元输入到输出之间的映射关系，一般为非线性函数</li><li>网络的拓扑结构：不同神经元之间的连接关系</li><li>学习算法：通过训练数据来学习神经网络的参数</li></ol><p>人工神经网络由神经元模型构成，这种由许多神经元组成的信息处理网络具有并行分布结构：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614204713506.png" alt="image-20230614204713506"><figcaption>image-20230614204713506</figcaption></figure></p><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>前馈神经网络（全连接神经网络、多层感知器）：</p><ul><li>各神经元分别属于不同的<strong>层</strong>，层内无连接</li><li>相邻两层之间的神经元全部<strong>两两连接</strong></li><li>整个网络中无反馈，信号从输入层向输出层单向传播，可用一个有向无环图表示</li></ul><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614205832741.png" alt="image-20230614205832741" style="zoom:67%;"><figcaption>image-20230614205832741</figcaption></figure><h3 id="前馈网络"><a href="#前馈网络" class="headerlink" title="前馈网络"></a>前馈网络</h3><p>给定一个前馈神经网络，我们用下面的记号来描述这个网络：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614205944157.png" alt="image-20230614205944157"><figcaption>image-20230614205944157</figcaption></figure></p><p>前馈神经网络通过下面的公式进行信息传播：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614210036585.png" alt="image-20230614210036585" style="zoom:50%;"><figcaption>image-20230614210036585</figcaption></figure></p><p>前馈计算：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614210057728.png" alt="image-20230614210057728"><figcaption>image-20230614210057728</figcaption></figure></p><h3 id="通用近似定理"><a href="#通用近似定理" class="headerlink" title="通用近似定理"></a>通用近似定理</h3><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614210345947.png" alt="image-20230614210345947" style="zoom: 50%;"><figcaption>image-20230614210345947</figcaption></figure><blockquote><p>根据通用近似定理，对于具有线性输出层和至少一个使用“挤压”性质的激活函数的隐藏层组成的前馈神经网络，只要其隐藏层神经元的数量足够，它可以以任意的精度来近似任何从一个定义在实数空间中的有界闭集函数</p></blockquote><h3 id="应用到机器学习"><a href="#应用到机器学习" class="headerlink" title="应用到机器学习"></a>应用到机器学习</h3><p>神经网络可以作为一个<strong>“万能”</strong>函数来使用，可以用来进行复杂的特征转换，或逼近一个复杂的条件分布<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614212133554.png" alt="image-20230614212133554"><figcaption>image-20230614212133554</figcaption></figure></p><p>如果g(.)为logistic回归，那么logistic回归分类器可以看成神经网络的最后一层</p><p>对于N类分类问题：<br>如果使用softmax回归分类器，相当于网络最后一层设置N个神经元，其输出经过softmax函数进行归一化后可以作为每个类的后验概率：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614214409036.png" alt="image-20230614214409036"><figcaption>image-20230614214409036</figcaption></figure><br>采用交叉熵损失函数，对于样本(x,y)，其损失函数为：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230614214454965.png" alt="image-20230614214454965"><figcaption>image-20230614214454965</figcaption></figure></p><h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616195315180.png" alt="image-20230616195315180"><figcaption>image-20230616195315180</figcaption></figure></p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616195401429.png" alt="image-20230616195401429"><figcaption>image-20230616195401429</figcaption></figure></p><p>如何计算梯度<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616210054860.png" alt="image-20230616210054860"><figcaption>image-20230616210054860</figcaption></figure></p><h3 id="深度学习的步骤"><a href="#深度学习的步骤" class="headerlink" title="深度学习的步骤"></a>深度学习的步骤</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616210208650.png" alt="image-20230616210208650"><figcaption>image-20230616210208650</figcaption></figure></p><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><p>难点：</p><ul><li><p>参数过多，影响训练</p></li><li><p>非凸优化问题：即存在局部最优而非全局最优解，影响迭代</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616210612271.png" alt="image-20230616210612271"><figcaption>image-20230616210612271</figcaption></figure></p></li><li><p>下层参数比较难调</p></li><li><p>参数解释起来比较困难</p></li></ul><p>需求：</p><ul><li>计算资源要大</li><li>数据要多</li><li>算法效率要好：即收敛快</li></ul><p>梯度消失问题<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616210657743.png" alt="image-20230616210657743"><figcaption>image-20230616210657743</figcaption></figure></p><h2 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h2><h3 id="神经元的训练"><a href="#神经元的训练" class="headerlink" title="神经元的训练"></a>神经元的训练</h3><p>训练的过程就是<strong>不断更新权重w和偏置b</strong>的过程，直到找到稳定的w和b使得模型的<strong>整体误差最小</strong>：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616211205201.png" alt="image-20230616211205201"><figcaption>image-20230616211205201</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616211213065.png" alt="image-20230616211213065"><figcaption>image-20230616211213065</figcaption></figure></p><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>前向传播</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616212642583.png" alt="image-20230616212642583"><figcaption>image-20230616212642583</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616212659347.png" alt="image-20230616212659347"><figcaption>image-20230616212659347</figcaption></figure></p><p>损失函数</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616212735211.png" alt="image-20230616212735211"><figcaption>image-20230616212735211</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616212816520.png" alt="image-20230616212816520"><figcaption>image-20230616212816520</figcaption></figure></p><h3 id="BP算法实例"><a href="#BP算法实例" class="headerlink" title="BP算法实例"></a>BP算法实例</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616212922251.png" alt="image-20230616212922251"><figcaption>image-20230616212922251</figcaption></figure></p><p>设定了输入，和神经元之间的权重</p><p>训练步骤：</p><p>正向计算-1：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616213351479.png" alt="image-20230616213351479"><figcaption>image-20230616213351479</figcaption></figure></p><p>进行了隐藏层的相关计算</p><p>正向计算-2：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616213514535.png" alt="image-20230616213514535"><figcaption>image-20230616213514535</figcaption></figure></p><p>进行了输出层的相关计算</p><p>损失Cost计算：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616213652658.png" alt="image-20230616213652658"><figcaption>image-20230616213652658</figcaption></figure></p><p>计算了损失</p><p>反向传播-1：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616213730036.png" alt="image-20230616213730036"><figcaption>image-20230616213730036</figcaption></figure></p><p>反向传播-2：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616213813803.png" alt="image-20230616213813803"><figcaption>image-20230616213813803</figcaption></figure></p><p>反向传播-3：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616215330990.png" alt="image-20230616215330990"><figcaption>image-20230616215330990</figcaption></figure></p><p>对W32、W41、W42同理计算</p><p>更新权值：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616215430254.png" alt="image-20230616215430254"><figcaption>image-20230616215430254</figcaption></figure></p><p>迭代更新：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616215507162.png" alt="image-20230616215507162"><figcaption>image-20230616215507162</figcaption></figure></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>全连接前馈神经网络缺点：<br>权重矩阵的参数非常多<br>局部不变性特征</p><ul><li>自然图像中的物体都具有局部不变性特征，比如尺度缩放、平移、旋转等操作不影响其语义信息</li><li>而全连接前馈神经网络很难提取这些局部不变特征</li></ul><h3 id="卷积神经网络的由来"><a href="#卷积神经网络的由来" class="headerlink" title="卷积神经网络的由来"></a>卷积神经网络的由来</h3><h3 id="卷积神经网络概念及特性"><a href="#卷积神经网络概念及特性" class="headerlink" title="卷积神经网络概念及特性"></a>卷积神经网络概念及特性</h3><p>卷积神经网络是一种前馈神经网络：</p><ul><li>卷积神经网络是受生物学学上“<strong>感受野</strong>”的机制提出而提出的</li><li>在视觉神经系统中，一个神经元的“<strong>感受野</strong>”是指视网膜上的<strong>特定区域</strong>，只有这个区域内的刺激才能够激活该神经元</li></ul><p>卷积神经网络有三个结构上的特性：</p><ul><li>局部连接</li><li>权重共享</li><li>空间或时间上的次采样</li></ul><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>卷积经常用在信号处理中，用于计算信号的延迟累积。<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618115758487.png" alt="image-20230618115758487"><figcaption>image-20230618115758487</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618115842373.png" alt="image-20230618115842373"><figcaption>image-20230618115842373</figcaption></figure></p><p>两维卷积<br>在图像处理中，图像是以二维矩阵的形式输入到神经网络中，因此我们需要二维卷积（下面图像好像有问题）<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618132418413.png" alt="image-20230618132418413"><figcaption>image-20230618132418413</figcaption></figure></p><h4 id="卷积的运算过程"><a href="#卷积的运算过程" class="headerlink" title="卷积的运算过程"></a>卷积的运算过程</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618130140090.png" alt="image-20230618130140090"><figcaption>image-20230618130140090</figcaption></figure></p><h4 id="卷积扩展"><a href="#卷积扩展" class="headerlink" title="卷积扩展"></a>卷积扩展</h4><p>引入滤波器的 <strong>滑动步长s</strong> 和 <strong>零填充p</strong></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618130358201.png" alt="image-20230618130358201"><figcaption>image-20230618130358201</figcaption></figure></p><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>在进行卷积运算时，输入矩阵的边缘会比矩阵内部的元素计算次数少，且输出的矩阵的大小会在卷积运算中相比较于输入的尺寸变小。因此，可在输入的矩阵的四周补零，称为padding，其大小为P。比如当P&#x3D;1时，原输入3*3的矩阵如下，实线框中为原矩阵，周围使用0作为padding：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618132025481.png" alt="image-20230618132025481"><figcaption>image-20230618132025481</figcaption></figure></p><p>一般来说，如果在高的两侧一共填充Ph行，在宽的两侧一共填充Pw列，那么输出形状将会是：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618132003364.png" alt="image-20230618132003364"><figcaption>image-20230618132003364</figcaption></figure></p><h4 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h4><p>在先前的例子里，卷积窗口从输入数组的<strong>最左上方开始，按从左往右、从上往下</strong>的顺序，依次在输入数组上滑动。每次滑动的行数和列数称为<strong>步幅</strong>，先前的例子里，在高和宽两个方向上步幅均为1.当然，根据实际情况也可以使用更大的步幅。如下图所示（实际输入为3*3，高、宽各以0值填充1行&#x2F;列），在高上步幅为3、在宽上步幅为2的卷积运算。可以看到，输出第一列第二个元素时，卷积窗口向下滑动了3行，而在输出第一行第二个元素时卷积窗口向右滑动了2列。当卷积窗口在输入数组上再向右滑动2列时，由于输入元素无法填满窗口，无结果输出：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618133428149.png" alt="image-20230618133428149"><figcaption>image-20230618133428149</figcaption></figure></p><p>一般来说，当高上步幅为Sh，宽上步幅为Sw时，输出形状为：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618133525290.png" alt="image-20230618133525290"><figcaption>image-20230618133525290</figcaption></figure></p><h4 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h4><p>前面例子中用到的输入和输出都是二维数组，<strong>但真实数据的维度经常更高</strong>。例如，彩色图像在高和宽两个维度外还有RGB（红、绿、蓝）3个颜色通道。假设彩色图像的高和宽分别是h和w（像素），那么它可以表示为一个3hw的多维数组，<strong>将大小为3的这一维称为通道（channel）维</strong>。当输入数据含多个通道时，一般需要构造一个<strong>输入通道数与输入数据的通道数相同的卷积核</strong>，从而能够与含多通道的输入数据做卷积运算。</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618134254873.png" alt="image-20230618134254873"><figcaption>image-20230618134254873</figcaption></figure></p><h3 id="卷积类型"><a href="#卷积类型" class="headerlink" title="卷积类型"></a>卷积类型</h3><p>卷积的结果按输出长度不同可以分为三类：</p><ul><li>窄卷积：步长s&#x3D;1，两端不补零p&#x3D;0，卷积后输出长度为n-m+1</li><li>宽卷积：步长s&#x3D;1，两端补零p&#x3D;m-1，卷积后输出长度为n+m-1</li><li>等长卷积：步长s&#x3D;1，两端补零p&#x3D;(m-1)&#x2F;2，卷积后输出长度n</li></ul><blockquote><p>在早期的文献中，卷积一般默认为窄卷积，而在目前的文献中，卷积一般默认为等宽卷积</p></blockquote><h5 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h5><p>通过卷积操作来实现高维特征到低维特征的转换。比如在一维卷积中，一个5维的输入特征，经过一个大小为3的卷积核，其输出为3维特征，如果设置步长大于1，可以进一步降低输出特征的维数。但在一些任务中，需要通过将低维特征映射到高维特征，并且依然希望通过卷积操作来实现，这种卷积操作称为<strong>转置卷积。</strong></p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618155119379.png" alt="image-20230618155119379" style="zoom:50%;"><figcaption>image-20230618155119379</figcaption></figure><h5 id="微步卷积"><a href="#微步卷积" class="headerlink" title="微步卷积"></a>微步卷积</h5><p>可以通过增加卷积操作的步长s&gt;1来实现对输入特征的降采样操作，大幅降低特征维数。同样，也可以通过减少转置卷积的步长s&lt;1来实现上采样操作，大幅提高特征维数。<br>步长s&lt;1的转置卷积也称为<strong>微步卷积</strong>。为了实现微步卷积，可以在输入特征之间插入0来间接地使得步长变小。</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618155610329.png" alt="image-20230618155610329" style="zoom:50%;"><figcaption>image-20230618155610329</figcaption></figure><h5 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h5><p>如何增加输出单元的感受野？可以通过以下方法：</p><ul><li>增加卷积核的大小</li><li>增加层数来实现</li><li>在卷积之前进行汇聚操作</li></ul><p><strong>空洞卷积</strong>：通过卷积核插入“空洞”来变相地增加其大小</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618155902249.png" alt="image-20230618155902249" style="zoom: 50%;"><figcaption>image-20230618155902249</figcaption></figure><h3 id="卷积神经网络的基本组成"><a href="#卷积神经网络的基本组成" class="headerlink" title="卷积神经网络的基本组成"></a>卷积神经网络的基本组成</h3><p>用卷积层代替全连接层</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618160039086.png" alt="image-20230618160039086" style="zoom:50%;"><figcaption>image-20230618160039086</figcaption></figure><p>输入：D个特征映射 M x N x D<br>输出：P个特征映射 M’ x N’ x P</p><p>特征映射：一幅图像经过卷积后得到的特征<br>卷积核看成一个特征提取器</p><p>典型的卷积层可以表示成3维结构</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618160922908.png" alt="image-20230618160922908"><figcaption>image-20230618160922908</figcaption></figure></p><h4 id="卷积层的映射关系"><a href="#卷积层的映射关系" class="headerlink" title="卷积层的映射关系"></a>卷积层的映射关系</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618160609079.png" alt="image-20230618160609079"><figcaption>image-20230618160609079</figcaption></figure></p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>池化层（Pooling Layer）也叫子采样层，其作用是进行<strong>特征选择，降低特征数量</strong>，并从而减少参数数量。<br>卷积层虽然可以显著减少连接的个数，但是每一个特征映射的神经元个数并没有显著减少。如果后面接一个分类器，每个分类器的输入维数依然很高，很容易出现过拟合。为了解决这个问题，可以<strong>在卷积层之后加上一个池化层</strong>，从而降低特征维数，<strong>避免过拟合</strong>。</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618161615395.png" alt="image-20230618161615395"><figcaption>image-20230618161615395</figcaption></figure></p><p>最大池化层（max pooling）：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618161734473.png" alt="image-20230618161734473" style="zoom:67%;"><figcaption>image-20230618161734473</figcaption></figure></p><blockquote><p>特点：能很好的保留纹理特征</p></blockquote><p>平均池化层（mean&#x2F;average pooling）:<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618161839234.png" alt="image-20230618161839234" style="zoom:67%;"><figcaption>image-20230618161839234</figcaption></figure></p><blockquote><p>特点：能很好的保留背景，但容易使得图片变模糊</p></blockquote><h4 id="卷积网络结构"><a href="#卷积网络结构" class="headerlink" title="卷积网络结构"></a>卷积网络结构</h4><p>卷积网络是由卷积层、池化层、全连接层交叉堆叠而成<br>趋向于小卷积、大深度<br>趋向于全卷积</p><p>典型结构</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618162536909.png" alt="image-20230618162536909"><figcaption>image-20230618162536909</figcaption></figure></p><p>一个卷积块为连续M个卷积层和b个池化层（M通常设置为2-5，b为0或1）.一个卷积网络中可以堆叠N个连续的卷积块，然后在接着K个全连接层（N的取值区间比较大，比如1-100或者更大；K一般为0-2）。</p><h3 id="卷积神经网络的学习能力"><a href="#卷积神经网络的学习能力" class="headerlink" title="卷积神经网络的学习能力"></a>卷积神经网络的学习能力</h3><h4 id="卷积的作用"><a href="#卷积的作用" class="headerlink" title="卷积的作用"></a>卷积的作用</h4><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618162714881.png" alt="image-20230618162714881" style="zoom: 67%;"><figcaption>image-20230618162714881</figcaption></figure><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618162843338.png" alt="image-20230618162843338" style="zoom: 50%;"><figcaption>image-20230618162843338</figcaption></figure><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618162910807.png" alt="image-20230618162910807" style="zoom:50%;"><figcaption>image-20230618162910807</figcaption></figure><h4 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h4><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163218221.png" alt="image-20230618163218221" style="zoom: 50%;"><figcaption>image-20230618163218221</figcaption></figure><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163226605.png" alt="image-20230618163226605"><figcaption>image-20230618163226605</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163234326.png" alt="image-20230618163234326"><figcaption>image-20230618163234326</figcaption></figure></p><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163814108.png" alt="image-20230618163814108"><figcaption>image-20230618163814108</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163917974.png" alt="image-20230618163917974"><figcaption>image-20230618163917974</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163928435.png" alt="image-20230618163928435"><figcaption>image-20230618163928435</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618163937133.png" alt="image-20230618163937133"><figcaption>image-20230618163937133</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618164416777.png" alt="image-20230618164416777"><figcaption>image-20230618164416777</figcaption></figure></p><blockquote><p>注意：C3层是一个卷积层16核卷积，C3并不是与S2全连接而是部分连接。C3层的第0-5个特征映射依赖于S2层的特征映射组的每3个连续子集，第6-11个特征映射依赖于S2层的特征映射组的每4个连续子集，第15个特征映射依赖于S2层的所有特征映射。</p></blockquote><p>论文中提及了如此组合的原因：</p><ul><li>减少参数</li><li>这种不对称的组合连接的方式有利于提取多种组合特征</li></ul><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618164812981.png" alt="image-20230618164812981"><figcaption>image-20230618164812981</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618164821840.png" alt="image-20230618164821840"><figcaption>image-20230618164821840</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618164836618.png" alt="image-20230618164836618"><figcaption>image-20230618164836618</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618164846632.png" alt="image-20230618164846632"><figcaption>image-20230618164846632</figcaption></figure></p><p>LeNet-5是一种用于手写体字符识别的非常高效的卷积神经网络。卷积神经网络能够很好的利用图像的结构信息。卷积层的参数较少，这也是由卷积层的<strong>主要特性即局部连接和共享权重</strong>所决定。</p><h3 id="典型的卷积网络"><a href="#典型的卷积网络" class="headerlink" title="典型的卷积网络"></a>典型的卷积网络</h3><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618165841310.png" alt="image-20230618165841310"><figcaption>image-20230618165841310</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618165930224.png" alt="image-20230618165930224"><figcaption>image-20230618165930224</figcaption></figure></p><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618165814453.png" alt="image-20230618165814453"><figcaption>image-20230618165814453</figcaption></figure></p><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170017607.png" alt="image-20230618170017607"><figcaption>image-20230618170017607</figcaption></figure></p><h4 id="Inception网络"><a href="#Inception网络" class="headerlink" title="Inception网络"></a>Inception网络</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170209900.png" alt="image-20230618170209900"><figcaption>image-20230618170209900</figcaption></figure></p><p>Inception-V1</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170227381.png" alt="image-20230618170227381"><figcaption>image-20230618170227381</figcaption></figure></p><p>Inception-V3</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170242557.png" alt="image-20230618170242557"><figcaption>image-20230618170242557</figcaption></figure></p><h4 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170058279.png" alt="image-20230618170058279"><figcaption>image-20230618170058279</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230618170728825.png" alt="image-20230618170728825"><figcaption>image-20230618170728825</figcaption></figure></p><h3 id="卷积神经网络在NLP中的应用"><a href="#卷积神经网络在NLP中的应用" class="headerlink" title="卷积神经网络在NLP中的应用"></a>卷积神经网络在NLP中的应用</h3><ol><li>Ngram特征与卷积</li><li>文本序列的卷积</li><li>基于卷积的句子表示</li><li>AlphaGo</li><li>Mask RCNN</li><li>OCR</li><li>图像生成</li><li>Deep Dream</li><li>画风迁移</li><li>对抗样本</li></ol>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>http://xuanyin02.github.io/2023/061444686.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>算法与数据结构</title>
      <link>http://xuanyin02.github.io/2023/060851507.html</link>
      <guid>http://xuanyin02.github.io/2023/060851507.html</guid>
      <pubDate>Thu, 08 Jun 2023 08:39:36 GMT</pubDate>
      
      <description>算法与数据结构对于程序员来说十分重要！不仅仅在笔试、面试的时候会遇到考察其知识点，学会了算法与数据结构对我们思维、编程很有帮助，让我们一起来学习！</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h3><p>算法（Algorithm）：一个计算过程，解决问题的方法。</p><p>Niklaus Wirth说过：“程序&#x3D;数据结构+算法”</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度：用来评估算法运行效率的一个式子。一般来说，时间复杂度高的算法比复杂度低的算法慢</p><p>常见的时间复杂度：O(1)&lt;O(logn)&lt;O(n)</p><p>快速判断算法复杂度（适用于绝大多数简单情况）：</p><ul><li>确定问题规模n</li><li>循环减半过程-&gt;logn</li><li>k层关于n的循环-&gt;n**k</li></ul><p>复杂情况：根据算法执行过程判断</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度：用来评估算法内存占用大小的式子</p><p>空间复杂度的表示方式与实践复杂度完全一样：</p><ul><li>算法使用了几个变量：O(1)</li><li>算法使用了长度为n的一维列表：O(n)</li><li>算法使用了m行n列的二维列表：O(mn)</li></ul><p>“空间换时间”：时间比空间重要，分布式技术就是这个原理</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的两个特点：</p><ul><li>调用自身</li><li>结束条件</li></ul><blockquote><p>了解了以上概念，我们就开始真正的学习算法了！</p></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程<br>列表查找（线性表查找）：从列表中查找指定元素<br>输入：列表、待查找元素；输出：元素下标（未找到元素时一般返回None或-1）<br>内置列表查找函数：index()</p><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#线性查找</span><span class="token keyword">def</span> <span class="token function">linear_search</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> ind<span class="token punctuation">,</span>val <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> val <span class="token operator">==</span> value<span class="token punctuation">:</span>            <span class="token keyword">return</span> ind        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">return</span> None</code></pre><p>时间复杂度：O(n)</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找：又叫折半查找，从有序列表的初始候选区li[0:n]开始，通过对 待查找 的值与候选区中间值的比较，可以使候选区减少一般</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#二分查找</span><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">0</span>    right <span class="token operator">=</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#候选区有值</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> li<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">:</span>            <span class="token keyword">return</span> mid        <span class="token keyword">elif</span> li<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> None</code></pre><p>时间复杂度：O(logn)</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列<br>列表排序：将无序列表变为有序列表<br>输入：列表；输出：有序列表<br>升序与降序<br>内置排序函数：sort()</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>列表每两个相邻的数，如果前面比后面大，则交换这两个数<br>一趟排序完成后，则无序区减少一个数，有序区增加一个数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#第i趟，总共需要排n-1趟</span>        exchage <span class="token operator">=</span> <span class="token boolean">False</span>     <span class="token comment" spellcheck="true">#标志位，因为后面可能在某一趟就已经排好序了，后面就不需要再执行遍历交换</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#遍历无序区的数字</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                exchage <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> exchage<span class="token punctuation">:</span>            <span class="token keyword">return</span></code></pre><p>时间复杂度：O(n**2)</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>一趟排序记录最小的数，放到第一个位置<br>再一趟排序记录列表无序区最小的数，放到第二个位置<br>算法关键点：有序区和无序区、无序区最小数的位置</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#i是第几趟</span>        min_loc <span class="token operator">=</span> i<span class="token comment" spellcheck="true">#初始化最小值的下标</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_loc <span class="token operator">=</span> j        li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span>    <span class="token keyword">return</span> li</code></pre><p>时间复杂度：O(n**2)</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>初始时手里（有序区）只有一张牌<br>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#表示摸到的牌的下标</span>        tmp <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        j <span class="token operator">=</span> i<span class="token number">-1</span> <span class="token comment" spellcheck="true">#j指的是手里的牌的下标</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#右移的条件</span>            li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp   <span class="token comment" spellcheck="true">#插入</span>    <span class="token keyword">return</span> li</code></pre><p>时间复杂度：O(n**2)</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>取一个元素p（第一个元素）使元素p归位–到他该到的位置<br>列表被p分成两部分，左边都比p小，右边都比p大<br>递归左右两边完成排序</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    tmp <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> tmp<span class="token punctuation">:</span>     <span class="token comment" spellcheck="true">#从右边找比tmp小的数,这里再加一个判断left&lt;right是为了当右边全比tmp大时，可以直接跳出while循环，不再执行下面的向右走循环</span>            right <span class="token operator">-=</span> <span class="token number">1</span>      <span class="token comment" spellcheck="true">#往左走一步</span>        li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#把右边的值写到左边的空位上</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">:</span>     <span class="token comment" spellcheck="true">#从左边找比tmp大的数</span>            left <span class="token operator">+=</span> <span class="token number">1</span>       <span class="token comment" spellcheck="true">#往右走一步</span>        li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#把左边的值写到左边的空位上</span>    li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> tmp      <span class="token comment" spellcheck="true">#把tmp归位</span>    <span class="token keyword">return</span> left    <span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#至少两个元素</span>        mid <span class="token operator">=</span> partition<span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span></code></pre><p>时间复杂度：O(nlogn)</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="堆排序前传–树与二叉树"><a href="#堆排序前传–树与二叉树" class="headerlink" title="堆排序前传–树与二叉树"></a>堆排序前传–树与二叉树</h5><p>树是一种可以递归定义的数据结构，比如：目录结构<br>树是由n个节点组成的集合：</p><ul><li>如果n&#x3D;0，那这是一棵空树</li><li>如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树</li></ul><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230608181705424.png" alt="image-20230608181705424" style="zoom:50%;"><figcaption>image-20230608181705424</figcaption></figure><blockquote><p>树的度：节点往下分几个叉</p></blockquote><p>二叉树：度不超过2的树<br>每个节点最多有两个孩子节点<br>两个孩子节点被区分为左孩子节点和右孩子节点</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230608182145712.png" alt="image-20230608182145712" style="zoom:50%;"><figcaption>image-20230608182145712</figcaption></figure><p>满二叉树：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230608182540016.png" alt="image-20230608182540016" style="zoom:50%;"><figcaption>image-20230608182540016</figcaption></figure><p>完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230608182558126.png" alt="image-20230608182558126" style="zoom:50%;"><figcaption>image-20230608182558126</figcaption></figure><p>二叉树的存储方式（表示方式）：</p><ul><li>链式存储方式</li><li>顺序存储方式</li></ul><h5 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h5><p>堆：一种特殊的完全二叉树结构<br>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大<br>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</p><p>堆的<strong>向下调整</strong>：假设：节点的左右子树都是堆，但自身不是堆。当根节点的左右子树都是堆时，可以通过一次向下的调整来将其换成一个堆</p><p>如何进行堆排序：</p><ol><li>建立堆。</li><li>得到堆顶元素。</li><li>去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。</li><li>堆顶元素为第二大元素。</li><li>重复步骤3、4，直到堆空。</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#向下调整过程</span><span class="token keyword">def</span> <span class="token function">sift</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param li: 列表    :param low: 堆的根节点位置    :param right: 堆的最后一个元素的位置    :return:    """</span>    i <span class="token operator">=</span> low<span class="token comment" spellcheck="true">#i最开始指向根节点</span>    j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token comment" spellcheck="true">#j开始是左孩子</span>    tmp <span class="token operator">=</span> li<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#把堆顶存起来</span>    <span class="token keyword">while</span> j <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果右孩子有并且比较大</span>        <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span>high <span class="token operator">and</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span> <span class="token comment" spellcheck="true">#j指向右孩子</span>        <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            i <span class="token operator">=</span> j       <span class="token comment" spellcheck="true">#往下看一层</span>            j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#tmp更大，把tmp放到i的位置上</span>            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token comment" spellcheck="true">#把tmp放到某一级领导的位置</span>            <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token comment" spellcheck="true">#把tmp放到叶子节点上的位置</span><span class="token comment" spellcheck="true">#实现堆排序</span><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#i表示建堆的时候调整的部分的根的下标</span>        sift<span class="token punctuation">(</span>li<span class="token punctuation">,</span>i<span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#建堆完成</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#i指向堆的最后一个位置</span>        li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        sift<span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#i-1是新的high</span></code></pre><p>时间复杂度：O(nlogn)</p><h5 id="堆排序–内置模块"><a href="#堆排序–内置模块" class="headerlink" title="堆排序–内置模块"></a>堆排序–内置模块</h5><p>Python内置模块–heapq</p><p>常用函数：</p><ul><li>heapify(x)#建堆</li><li>heappush(heap,item)</li><li>heappop(heap)</li></ul><h5 id="堆排序–topk问题"><a href="#堆排序–topk问题" class="headerlink" title="堆排序–topk问题"></a>堆排序–topk问题</h5><p>现在有n个数，设计算法得到前k大的数（k&lt;n）</p><p>解决思路：</p><p>取列表前k个元素建立一个小根堆，堆顶就是目前第k大的数<br>依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sift</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> low    j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>    tmp <span class="token operator">=</span> li<span class="token punctuation">[</span>low<span class="token punctuation">]</span>    <span class="token keyword">while</span> j <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> high <span class="token operator">and</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> tmp<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            i <span class="token operator">=</span> j            j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">def</span> <span class="token function">topk</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 1、建堆</span>    heap <span class="token operator">=</span> li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sift<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#2、遍历</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            sift<span class="token punctuation">(</span>heap<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#3、出数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        sift<span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> heap</code></pre><p>时间复杂度：O(nlogk)</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>分解：将列表约分越小，直至分成一个元素<br>终止条件：一个元素是有序的<br>合并：将两个有序列表归并，列表越来越大</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> low    j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    ltmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> i<span class="token operator">&lt;=</span>mid <span class="token operator">and</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#只要左右两边都有数</span>        <span class="token keyword">if</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            ltmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ltmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            j <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">#while执行完，肯定有一部分没数了</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> mid<span class="token punctuation">:</span>        ltmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">while</span> j <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        ltmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        j <span class="token operator">+=</span> <span class="token number">1</span>    li<span class="token punctuation">[</span>low<span class="token punctuation">:</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ltmp<span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span>  high<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#至少有两个元素</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        merge_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span>        merge_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span>        merge<span class="token punctuation">(</span>li<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span></code></pre><p>时间复杂度：O(nlogn)</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是一种分组插入排序算法<br>首先取一个整数d1&#x3D;n&#x2F;2，将元素分为d1个组，每组相邻量元素之间距离为d1，在各组内进行直接插入排序<br>取第二个整数d2&#x3D;d1&#x2F;2，重复上诉分组排序过程，直到di&#x3D;1，即所有元素在同一组内进行直接插入排序<br>希尔排序每趟并不使某些元素有序，而是整体数据越来越接近有序；最后一趟排序使得所有数据有序</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert_sort_gap</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>gap<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#表示摸到的牌的下标</span>        tmp <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        j <span class="token operator">=</span> i<span class="token operator">-</span>gap <span class="token comment" spellcheck="true">#j指的是手里的牌的下标</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右移的条件</span>            li<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span> gap        li<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token comment" spellcheck="true">#插入</span><span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    d <span class="token operator">=</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">while</span> d <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>        insert_sort_gap<span class="token punctuation">(</span>li<span class="token punctuation">,</span>d<span class="token punctuation">)</span>        d <span class="token operator">//=</span> <span class="token number">2</span></code></pre><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>对列表进行排序，已知列表中的数范围都在0到100之间。设计时间复杂度为O(n)的算法<br>建立一个列表，下标为0~100，值为当前下标在列表中出现的次数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>max_count<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> val <span class="token keyword">in</span> li<span class="token punctuation">:</span>        count<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    li<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> ind<span class="token punctuation">,</span>val <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>            li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ind<span class="token punctuation">)</span></code></pre><p>在计数排序中，如果元素的范围比较大（比如在1到1亿之间），如何改造算法？桶排序是一个解决方法<br>桶排序：首先将元素分在不同的桶中，再对每个桶中的元素排序<br>比如最大的数是10000，第一个桶就是0<del>100，第二个桶就是101</del>200 …</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>max_num<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#创建桶</span>    <span class="token keyword">for</span> val <span class="token keyword">in</span> li<span class="token punctuation">:</span>        i <span class="token operator">=</span> min<span class="token punctuation">(</span>val <span class="token operator">//</span> <span class="token punctuation">(</span>max_num <span class="token operator">//</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#i表示val放到几号桶中</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#把val加到桶里</span>        <span class="token comment" spellcheck="true">#保持桶内的顺序</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>    sorted_li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> buc <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>        sorted_li<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>buc<span class="token punctuation">)</span>    <span class="token keyword">return</span> sorted_li</code></pre><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>多关键字排序：假如现在有一个员工表，要求按照年龄排序，年龄相同的员工按照工资排序<br>先按照年龄进行排序，再按照薪资进行稳定的排序</p><p>数字的排序也可以看作是多关键字排序：比如两位数的数字进行比较，先比较十位，再比较个位 …</p><p>但是在此算法中，我们是先从最后一位开始排序，再一次排序前一位</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    max_num <span class="token operator">=</span> max<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#最大值 9->1位数，99->2位数，999->3位数，1000->4位数</span>    it <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#位数标志符</span>    <span class="token keyword">while</span> <span class="token number">10</span> <span class="token operator">**</span> it <span class="token operator">&lt;=</span> max_num<span class="token punctuation">:</span>        buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> val <span class="token keyword">in</span> li<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#987 it=0 987%10->7;    it=1 987//10->98 98%10->8;  it=2 987//100->9</span>            digit <span class="token operator">=</span> <span class="token punctuation">(</span>val <span class="token operator">//</span> <span class="token number">10</span> <span class="token operator">**</span> it<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span>            buckets<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#分桶完成</span>        li<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> buc <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 把数重新写回li</span>            li<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>buc<span class="token punctuation">)</span>        it <span class="token operator">+=</span> <span class="token number">1</span></code></pre><p>时间复杂度：O(max_num*n)</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h3><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成</p><p>简单来说，数据结构就是设计数据以何种方式组织并存储在计算机中</p><p>比如：列表、集合与字典等都是一种数据结构</p><p>Niklaus Wirth说过：“程序&#x3D;数据结构+算法”</p><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>数据结构按照其逻辑结构可分为线性结构、树结构、图结构</p><ul><li>线性结构：数据结构中的元素存在一对一的相互关系</li><li>树结构：数据结构中的元素存在一对多的相互关系</li><li>图结构：数据结构中的元素存在多对多的相互关系</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表（其他语言称数组）是一种基本数据类型</p><p>列表的元素类型可以不同</p><p>python存列表存的不是值，而是地址</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h4><p>栈（Stack）是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表<br>栈的特点：后进先出LIFO（last-in，first-out）<br>栈的概念：栈顶、栈底<br>栈的基本操作：</p><ul><li>进栈（压栈）：push</li><li>出栈：pop</li><li>取栈顶：gettop</li></ul><h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>使用一般的列表结构即可实现栈：</p><ul><li>进栈：li.append</li><li>出栈：li.pop</li><li>取栈顶：li[-1]</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>element<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h4><p>队列（Queue）是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除<br>进行插入的一端称为队尾（rear），插入动作称为进队或入队<br>进行删除的一端称为对头（front），删除动作称为出队<br>队列的性质：先进先出FIFO（First-in，First-out）</p><h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><p>环形队列：当前对位指针front&#x3D;&#x3D;MaxSize+1时，再前进一个位置就自动到0</p><ul><li>队首指针前进1：front&#x3D;（front+1）%MaxSize</li><li>队尾指针前进1：rear&#x3D;（rear+1）%MaxSize</li><li>队空条件：rear&#x3D;&#x3D;front</li><li>队满条件：（rear+1）%MaxSize&#x3D;&#x3D;front</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> size        self<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">#队尾指针</span>        self<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true">#队首指针</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>is_filled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>size            self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span>self<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> element        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"Queue is Filled"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>size            <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span>self<span class="token punctuation">.</span>front<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"Queue is Empty"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#判断队空</span>    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>rear <span class="token operator">==</span> self<span class="token punctuation">.</span>front    <span class="token comment" spellcheck="true">#判断队满</span>    <span class="token keyword">def</span> <span class="token function">is_filled</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>front</code></pre><p>双向队列</p><p>双向队列的两端都支持进队和出队操作</p><p>双向队列的基本操作：</p><ul><li>队首进队</li><li>队首出队</li><li>队尾进队</li><li>队尾出队</li></ul><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230612184054851.png" alt="image-20230612184054851" style="zoom:50%;"><figcaption>image-20230612184054851</figcaption></figure><h4 id="队列的内置模块"><a href="#队列的内置模块" class="headerlink" title="队列的内置模块"></a>队列的内置模块</h4><p>使用方法：from collections import deque：</p><ul><li>创建队列：queue &#x3D; deque()</li><li>进队：append()</li><li>出队：popleft()</li><li>双向队列队首进队：appendleft()</li><li>双向队列队尾出队：pop()</li></ul>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</category>
      
      
      <comments>http://xuanyin02.github.io/2023/060851507.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java SSM框架</title>
      <link>http://xuanyin02.github.io/2023/06069152.html</link>
      <guid>http://xuanyin02.github.io/2023/06069152.html</guid>
      <pubDate>Tue, 06 Jun 2023 13:51:38 GMT</pubDate>
      
      <description>关于SSM框架：Spring+SpringMVC+SpringBoot的知识</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-Framework系统架构"><a href="#Spring-Framework系统架构" class="headerlink" title="Spring Framework系统架构"></a>Spring Framework系统架构</h3><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230606215746774.png" alt="image-20230606215746774"><figcaption>image-20230606215746774</figcaption></figure></p><h3 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h3><p>代码书写现状：耦合性偏高<br>解决方案：使用对象时，在程序中不要注定使用new产生对象，转换为由<strong>外部</strong>提供对象</p><h4 id="IoC（Inversion-of-Control）控制反转"><a href="#IoC（Inversion-of-Control）控制反转" class="headerlink" title="IoC（Inversion of Control）控制反转"></a>IoC（Inversion of Control）控制反转</h4><p>使用对象时，由主动new产生对象转换为<strong>由外部提供对象</strong>，此过程中对象的创建控制权由程序转移到<strong>外部</strong>，这种思想称为控制反转</p><p>Spring技术对IOC思想进行了实现：Spring提供了一个容器，称为<strong>IoC容器</strong>（系统架构中的Core Container），用来充当IoC思想的“<strong>外部</strong>”。<br>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中被称为<strong>Bean</strong></p><h4 id="DI-Dependency-Injection-依赖注入"><a href="#DI-Dependency-Injection-依赖注入" class="headerlink" title="DI (Dependency Injection) 依赖注入"></a>DI (Dependency Injection) 依赖注入</h4><p>在容器中建立Bena与Bean之间的依赖关系的整个过程,称为依赖注入</p><p>目标:充分解耦</p><ol><li>使用IoC容器管理bean (IoC)</li><li>在IoC容器内将有依赖关系的bean进行绑定 (DI)</li></ol><p>最终效果:使用对象时不仅可以直接从IoC容器中获取,并且获取到的bean已经绑定了所有的依赖关系</p><h5 id="Bean实例化方式"><a href="#Bean实例化方式" class="headerlink" title="Bean实例化方式"></a>Bean实例化方式</h5><ul><li>无参构造实例化bean</li><li>静态工厂实例化bean</li><li>实例工厂实例化bean</li><li>FactoryBean实例化bean</li></ul><h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><p>生命周期：从创建到消亡的完整过程<br>Bean生命周期：bean从创建到销毁的整体过程（对象从创建到销毁）<br>Bean生命周期控制：在bean创建后到销毁前做一些事情</p><p>1、bean生命周期控制：</p><ul><li><p>配置</p><p>init-method</p><p>destory-method</p></li><li><p>接口</p><p>InitializingBean</p><p>DisposableBean</p></li></ul><p>2、关闭容器：</p><ul><li><p>ConfigurableApplicationContext</p><p>close()</p><p>registerShutdownHook()</p></li></ul><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><p>向一个类中传递数据的方式：</p><ul><li>普通方法（set方法）</li><li>构造方法</li></ul><p>创建Bean依赖的数据类型：</p><ul><li>引用类型</li><li>简单类型（基本数据类型与String）</li></ul><p>依赖注入方式：</p><ul><li><p>setter注入</p><p>简单类型</p><p>引用类型</p></li><li><p>构造器注入</p><p>简单类型</p><p>引用类型</p></li></ul><p>依赖注入方式选择：</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</li><li>可选依赖使用setter注入进行，灵活性强</li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><p>依赖自动装配：</p><p>​    IoC容器根据bean所依赖的资源在容器中<strong>自动查找并注入</strong>到bean中的过程称为自动装配</p><p>自动装配方式：</p><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><p>依赖自动装配特征：</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现自动装配配置失效</li></ul><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p>创建容器：</p><ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li></ul><p>获取bean：</p><ul><li>获取之后强转</li><li>获取时添加获取的类型参数</li><li>按照类型获取</li></ul><h4 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h4><h5 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加载配置类初始化容器</span>ApplicationContext ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>SpringConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre><p>@Configuration注解用于设定当前类为配置类<br>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><p>Spring提供@Componemt注解的三个衍生注解</p><ol><li>@Controller：用于表现层bean定义</li><li>@Service：用于业务层bean定义</li><li>@Repository：用于数据层bean定义</li></ol><p>@Autowired注解用于自动装配类型<br>@Value注解用于设定简单类型的值<br>@PropertySource注解加载properties文件</p><h4 id="AOP（Aspect-Oriented-Programming）面向切面编程"><a href="#AOP（Aspect-Oriented-Programming）面向切面编程" class="headerlink" title="AOP（Aspect Oriented Programming）面向切面编程"></a>AOP（Aspect Oriented Programming）面向切面编程</h4><p>一种编程范式，指导开发者如何组织程序结构–（OOP（Object Oriented Programming）面向对象编程）</p><blockquote><p>作用：在不惊动原始设计的基础上为其进行<strong>功能增强</strong><br>Spring理念：无入侵式&#x2F;无侵入式</p></blockquote><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><ul><li>连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<br>在SpringAOP中，理解为方法的执行</li><li>切入点（PointCut）：要进行功能增强的方法<br>切入点表达式：匹配连接点的式子<br>在SpringAOP中，一个切入点表达式可以只描述一个具体方法，也可以匹配多个方法<br>一个具体方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法<br>匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li><li>通知（Advice）：在切入点处执行的操作，也就是共性功能<br>在SpringAOP中，功能最终以方法的形式呈现</li><li>通知类：定义通知的类</li><li>切面（Aspect）：描述通知与切入点的对应关系</li></ul><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ol><li><p>Spring容器启动</p></li><li><p>读取所有切面配置中的切入点</p></li><li><p>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</p><p>匹配失败，创建对象</p><p>匹配成功，创建原始对象（<strong>目标对象</strong>）的<strong>代理</strong>对象</p></li><li><p>获取bean执行方法</p><p>获取bean，调用方法并执行，完成操作</p><p> 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</p></li></ol><p>目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</p><p>代理（Proxy）：目标对象无法直接完成的工作，需要对其进行功能回填，通过原始对象的代理对象实现</p><blockquote><p>SpringAOP本质：代理模式</p></blockquote><h5 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h5><p>切入点表达式标准格式：动作关键字（访问修饰符 返回值 包名.类&#x2F;接口名.方法名（参数） 异常名）</p><blockquote><p>Execution (public User com.itheima.service.UserService.findById(int))</p></blockquote><ul><li>动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>可以使用通配符描述切入点，快速描述</li></ul><h5 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a>通知获取数据</h5><ul><li><p>获取切入点方法的参数</p><p>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</p><p>ProceedJoinPoint：适用于环绕通知</p></li><li><p>获取切入点方法返回值</p><p>返回后通知</p><p>环绕通知</p></li><li><p>获取切入点方法运行异常信息</p><p> 抛出异常后通知</p><p>环绕通知</p></li></ul><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><p>事务简介</p><p>Spring事务作用：在<strong>数据层或业务层</strong>保障一系列的数据库操作同成功同失败</p><p>开启事务步骤：</p><ol><li>在业务层接口上添加Spring事务管理</li><li>设置事务管理器</li><li>开启注解式事务驱动</li></ol><blockquote><p>注意事项：Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合。注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务。</p></blockquote><p>事务角色</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><p>事务属性</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230607225604276.png" alt="image-20230607225604276"><figcaption>image-20230607225604276</figcaption></figure></p><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h4><p>概述</p><p>SpringMVC技术与Servlet技术功能等同，均属于web层开发技术</p><p>SpringMVC是一种表现层框架技术，用于表现层功能开发</p><p>SpringMVC是一种基于Javahi实现MVC模型的轻量级WEB框架</p><p>优点</p><ul><li>使用简单，开发便捷</li><li>灵活性强</li></ul><h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p>名称：@Controller<br>类型：类注解<br>位置：SpringMVC控制器类定义上方<br>作用：设定SpringMVC的核心控制器bean<br>范例：     </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>名称：@ResponseBody<br>类型：方法注解<br>位置：SpringMVC控制器方法定义上方<br>作用：设置当前控制器方法响应内容为当前返回值，无需解析<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/save"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> String <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;'info':'springmvc'&amp;#125;"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h6 id="SpringMVC入门程序开发总结（1-N）"><a href="#SpringMVC入门程序开发总结（1-N）" class="headerlink" title="SpringMVC入门程序开发总结（1+N）"></a>SpringMVC入门程序开发总结（1+N）</h6><p>1次工作:</p><ul><li>创建工程，设置服务器，加载工程</li><li>导入坐标</li><li>创建Web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li><li>SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）</li></ul><p>N次工作:</p><ul><li>定义处理请求的控制器类</li><li>定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回json数据（@ResponseBody）</li></ul><h6 id="入门案例工作流程分析"><a href="#入门案例工作流程分析" class="headerlink" title="入门案例工作流程分析"></a>入门案例工作流程分析</h6><p>启动服务器初始化过程：</p><ol><li><p>服务器启动，执行ServletContainerInitConfig类，初始化web容器</p></li><li><p>执行createServletApplicationContext方法，创建了WebApplicationContext对象</p></li><li><p>加载SpringMvcConfig</p></li><li><p>执行@ComponentScan加载对应的bean</p></li><li><p>加载UserController，每个@RequestMapping的名称对应一个具体的方法</p></li><li><p>执行getServletMapping方法，定义所有的请求都通过SpringMVC</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230609230510011.png" alt="image-20230609230510011" style="zoom: 50%;"><figcaption>image-20230609230510011</figcaption></figure></li></ol><p>单次请求过程：</p><ol><li>发送请求localhost&#x2F;save</li><li>web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</li><li>解析请求路径&#x2F;save</li><li>由&#x2F;save匹配执行对应的方法save()</li><li>执行save()</li><li>检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</li></ol><h5 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h5><p>Controller加载控制与业务bean加载控制：（加载属于自己的bean）</p><p>SpringMVC相关bean（表现层bean）</p><p>Spring控制的bean：</p><ul><li>业务bean（Service）</li><li>功能bean（DataSource等）</li></ul><p>SpringMVC相关bean加载控制：</p><ul><li>SpringMVC加载的bean对应的包均在com.itheima.controller包内</li></ul><p>Spring相关bean加载控制：</p><ul><li>方式一：Spring加载的bena设定扫描范围为com.itheima，排除掉controller包内的bean</li><li>方式二：Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</li><li>方式三：不区分Spring和SpringMVC的环境，加载到同一个环境中</li></ul><p>名称：@ComponentScan<br>类型：类注解<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.itheima"</span><span class="token punctuation">,</span>excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>        type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span>        classes <span class="token operator">=</span> Controller<span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>属性：</p><ul><li>excludeFilters：排除扫描路径中加载的bean，需要指定类别(type)与具体项(classes)</li><li>includeFilters：加载指定的bean，需要指定类别(type)与具体项(classes)</li></ul><h4 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h4><h5 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h5><p>名称：@RequestMapping<br>类型：方法注解类注解<br>位置：SpringMVC控制器方法定义上方<br>作用：设置当前控制器方法请求访问路径，如果设置在类上统一设置当前控制器方法请求访问路径前缀<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/save"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"&amp;#123;'module':'user save'&amp;#125;"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>属性：</p><ul><li>value(默认)：请求访问路径，或访问路径前缀</li></ul><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><p>Get请求</p><p>Post请求</p><blockquote><p>SpringMVC中需要解决Post请求中文乱码问题</p></blockquote><h5 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h5><h6 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h6><p>普通参数：请求参数名与形参变量名不同，使用@RequestParam绑定参数关系<br>(@RequestParam(“”name) Strign userName, int age)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230610003158201.png" alt="image-20230610003158201"><figcaption>image-20230610003158201</figcaption></figure></p><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型参即可接收参数<br>(User user)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230610003227859.png" alt="image-20230610003227859"><figcaption>image-20230610003227859</figcaption></figure></p><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象<strong>层次结构关系</strong>即可接收嵌套POJO属性参数<br>(User user)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230610002515153.png" alt="image-20230610002515153"><figcaption>image-20230610002515153</figcaption></figure></p><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数<br>(String[] likes)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230610002719066.png" alt="image-20230610002719066"><figcaption>image-20230610002719066</figcaption></figure></p><p>集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系<br>(@RequestParam List<String> likes)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230610002945086.png" alt="image-20230610002945086"><figcaption>image-20230610002945086</figcaption></figure></String></p><h6 id="JSON数据参数"><a href="#JSON数据参数" class="headerlink" title="JSON数据参数"></a>JSON数据参数</h6><ol><li><p>发送数据<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./Java-SSM%E6%A1%86%E6%9E%B6/image-20230610003759113.png" alt="image-20230610003759113"><figcaption>image-20230610003759113</figcaption></figure></p></li><li><p>开启自动转换json数据的支持（在SpringMvcConfig中）<br>@EnableWebMvc</p></li><li><p>设置接收数据</p><p>JSON数据参数：(@RequestBody List<String> likes)–发送数据如上图</String></p><p>POJO参数：json数据与形参对象属性名相同，定义POJO类型形参即可接收参数<br>(@RequestBody User user)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./Java-SSM%E6%A1%86%E6%9E%B6/image-20230610004305035.png" alt="image-20230610004305035"><figcaption>image-20230610004305035</figcaption></figure></p><p>POJO集合参数：json数组数据与集合泛型 属性名形同，定义List类型形参即可接收参数<br>(@RequestBody List<User> list)<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./Java-SSM%E6%A1%86%E6%9E%B6/image-20230610004751808.png" alt="image-20230610004751808"><figcaption>image-20230610004751808</figcaption></figure></User></p></li></ol><h6 id="比较-RequestBody与-RequestParam"><a href="#比较-RequestBody与-RequestParam" class="headerlink" title="比较@RequestBody与@RequestParam"></a>比较@RequestBody与@RequestParam</h6><p>区别：</p><ul><li>@RequestParam用于接收url地址传参，表单传参[application&#x2F;x-www-form-urlencoded]</li><li>@RequestBody用于接收json数据[application&#x2F;json]</li></ul><p>应用：</p><ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul><h6 id="日期类型参数"><a href="#日期类型参数" class="headerlink" title="日期类型参数"></a>日期类型参数</h6><p>名称：@DateTimeFormat<br>类型：类注解<br>位置：SpringMVC控制器方法形参前面<br>作用：设定日期时间型数据格式<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/dataParam"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> String <span class="token function">dataParam</span><span class="token punctuation">(</span><span class="token annotation punctuation">@DateTimeFormat</span><span class="token punctuation">(</span>pattern<span class="token operator">=</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span> Date date<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"参数传递 date ==> "</span><span class="token operator">+</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;'module':'data param'&amp;#125;"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>属性：pattern：日期时间格式字符串</p><p>日期类型参数：(Date date,<br>@DateTimeFormat(pattern&#x3D;”yyyy-MM-dd”) Date date1,<br>@DateTimeFormat(pattern&#x3D;”yyyy&#x2F;MM&#x2F;dd HH:mm:ss”) Date date2)</p><h6 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h6><p>Converter接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>S<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    T <span class="token function">convert</span><span class="token punctuation">(</span>S var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>请求参数年龄数据（String -&gt; Integer）</li><li>日期格式数据（String -&gt; Date）</li></ul><blockquote><p>@EnableWebMvc功能之一：根据类型匹配对应的类型转换器</p></blockquote><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><p>响应页面</p><p>响应数据</p><ul><li>文本数据</li><li>json数据</li></ul><p>名称：@ResponseBody<br>类型：方法注解<br>位置：SpringMVC控制器方法定义上方<br>作用：设置当前控制器返回值作为响应体<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/save"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> String <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"save ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;'info':'springmvc'&amp;#125;"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h4><h5 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h5><p>REST(Representational State Transfer)，表现形式转换–<strong>访问网络资源的格式</strong></p><p>传统风格资源描述形式：</p><ul><li><a class="link" href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="http://localhost/user/saveUser">http://localhost/user/saveUser <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><p>REST风格描述形式：</p><ul><li><a class="link" href="http://localhost/user/1">http://localhost/user/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="http://localhost/user/">http://localhost/user/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><p>优点：</p><ul><li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作：</p><ul><li><a class="link" href="http://localhost/users">http://localhost/users <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>查询全部用户信息GET（查询）</li><li><a class="link" href="http://localhost/users/1">http://localhost/users/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>查询指定用户信息GET（查询）</li><li><a class="link" href="http://localhost/users">http://localhost/users <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>添加用户信息POST（新增&#x2F;保存）</li><li><a class="link" href="http://localhost/users">http://localhost/users <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>修改用户信息PUT（修改&#x2F;更新）</li><li><a class="link" href="http://localhost/users/1">http://localhost/users/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>删除用户信息DELETE（删除）</li></ul><blockquote><p>注意事项：上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范<br>描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如：users、books、accounts …</p></blockquote><p><strong>根据REST风格对资源进行访问称为<em>RESTful</em></strong></p><h5 id="RESTful入门案例"><a href="#RESTful入门案例" class="headerlink" title="RESTful入门案例"></a>RESTful入门案例</h5><p>步骤：</p><ol><li><p>设定http请求动作（动词）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/users"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span></code></pre></li><li><p>设定请求参数（路径变量）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/users/&amp;#123;id&amp;#125;"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> String <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> Integer id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user delete ..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;'module':'user delet'&amp;#125;"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h5 id="REST快速开发"><a href="#REST快速开发" class="headerlink" title="REST快速开发"></a>REST快速开发</h5><p>名称：@RestController<br>类型：类注解<br>位置：基于SpringMVC的RESTful开发控制器类定义上方<br>作用：设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>名称：@GetMapping@PostMapping@PutMapping@DeleteMapping<br>类型：方法注解<br>位置：基于SpringMVC的RESTful开发控制器方法定义上方<br>作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求<br>范例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&amp;#123;id&amp;#125;"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">getById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> Integer id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getById ..."</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;'module':'book getById'&amp;#125;"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="案例：基于RESTful页面数据交互"><a href="#案例：基于RESTful页面数据交互" class="headerlink" title="案例：基于RESTful页面数据交互"></a>案例：基于RESTful页面数据交互</h5><p>步骤：</p><ol><li><p>制作SpringMVC控制器，并通过Postman测试</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@PostMapping</span>    <span class="token keyword">public</span> String <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Book book<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book save ==> "</span> <span class="token operator">+</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"&amp;#123;'module':'book save success'&amp;#125;"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Book<span class="token operator">></span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"book getAll is running ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Book<span class="token operator">></span> bookList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Book<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Book book1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book1<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"SpringMVC入门教程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book1<span class="token punctuation">.</span><span class="token function">setDescription</span><span class="token punctuation">(</span><span class="token string">"小试牛刀"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bookList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>book1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//模拟数据...</span>        <span class="token keyword">return</span> bookList<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>设置对静态资源放行</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringMvcSupport</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>ResourceHandlerRegistry registry<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当访问/pages/???时候，走/pages目录下的内容</span>        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">"/pages/**"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">"/pages/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>前端页面通过异步提交访问后天控制器</p><pre class=" language-html"><code class="language-html">//添加saveBook()<span class="token entity" title="&#123;">&amp;#123;</span>    axios.post("/books",this.formData).then((res)=><span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span>);<span class="token entity" title="&#125;">&amp;#125;</span>,//this.formData表示要保存的数据//主页列表查询getAll()<span class="token entity" title="&#123;">&amp;#123;</span>    axios.get("/books").then((res)=><span class="token entity" title="&#123;">&amp;#123;</span>        this.dataList = res.data;    <span class="token entity" title="&#125;">&amp;#125;</span>)<span class="token entity" title="&#125;">&amp;#125;</span>//res.data是返回的数据</code></pre></li></ol><h4 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h4><h5 id="SSM整合流程"><a href="#SSM整合流程" class="headerlink" title="SSM整合流程"></a>SSM整合流程</h5><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613213934991.png" alt="image-20230613213934991" style="zoom: 50%;"><figcaption>image-20230613213934991</figcaption></figure><h6 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h6><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613225935865.png" alt="image-20230613225935865" style="zoom:50%;"><figcaption>image-20230613225935865</figcaption></figure><blockquote><p>记得<strong>事务处理</strong></p></blockquote><h6 id="Spring整合Spring-MVC"><a href="#Spring整合Spring-MVC" class="headerlink" title="Spring整合Spring MVC"></a>Spring整合Spring MVC</h6><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613230331323.png" alt="image-20230613230331323"><figcaption>image-20230613230331323</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613230355220.png" alt="image-20230613230355220"><figcaption>image-20230613230355220</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613230410789.png" alt="image-20230613230410789"><figcaption>image-20230613230410789</figcaption></figure></p><h5 id="表现层数据封装"><a href="#表现层数据封装" class="headerlink" title="表现层数据封装"></a>表现层数据封装</h5><p>概念：前端接收数据格式–封装特殊消息到message（msg）属性中</p><p>设置统一数据返回类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object data<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer code<span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意事项：Result类中的字段并不是固定的，可以根据需要自行增减。提供若干个构造方法，方便操作！</p></blockquote><p>设置统一数据返回结果编码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer SAVE_OK <span class="token operator">=</span> <span class="token number">20011</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer DELETE_OK <span class="token operator">=</span> <span class="token number">20021</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer SAVE_ERR <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer DELETE_ERR <span class="token operator">=</span> <span class="token number">20020</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意事项：Code类的常量设计也不是固定的，可以根据需要自行增减</p></blockquote><p>根据情况设定合理的Controller</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230613233629580.png" alt="image-20230613233629580"><figcaption>image-20230613233629580</figcaption></figure></p><h5 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h5><p>程序开发过程中不可避免的会遇到异常现象<br>各个层级均出现异常，异常处理代码书写在哪一层–所有的异常均抛出到表现层进行处理<br>表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决–AOP思想<br>Spring为了不让开发者去做AOP，创造了：<strong>异常处理器</strong><br>异常处理器：集中、统一的处理项目中出现的异常</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProjectExecptionAdvice</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@ExecptionHandler</span><span class="token punctuation">(</span>Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">doExecption</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h5><p>项目异常分类：</p><ul><li><p>业务异常</p><p>规范的用户行为产生的异常</p><p>不规范的用户行为操作产生的异常</p></li><li><p>系统异常</p><p>项目运行过程中可预计且无法避免的异常</p></li><li><p>其他异常</p><p>编程人员未预期到的异常</p></li></ul><p>项目异常处理方案：</p><ul><li><p>业务异常</p><p>发送对应消息传递给用户，提醒规范操作</p></li><li><p>系统异常</p><p>发送固定消息传递给用户，安抚用户</p><p>发送特定消息给运维人员，提醒维护</p><p>记录日志</p></li><li><p>其他异常</p><p>发送固定消息传递给用户，安抚用户</p><p>发送特定消息给开发人员，提醒维护（纳入预期范围内）</p><p>记录日志</p></li></ul><p>自定义项目系统级异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SystemException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer code<span class="token punctuation">;</span>    <span class="token keyword">public</span> Integer <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCode</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SystemException</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SystemException</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>自定义项目业务及异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer code<span class="token punctuation">;</span>    <span class="token keyword">public</span> Integer <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCode</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BusinessException</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BusinessException</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>自定义异常编码</p><p>设置触发自定义异常</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> BookDao bookdao<span class="token punctuation">;</span>    <span class="token keyword">public</span> Book <span class="token function">getById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BusinessException</span><span class="token punctuation">(</span>Code<span class="token punctuation">.</span>PROJECT_BUSINESS_ERR<span class="token punctuation">,</span><span class="token string">"请勿进行非法操作！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookdao<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>拦截并处理异常</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProjectExceptionAdvice</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@ExceptionHandler用于设置当前处理器类对应的异常类型</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>SystemException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">doSystemException</span><span class="token punctuation">(</span>SystemException ex<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录日志</span>        <span class="token comment" spellcheck="true">//发送消息给运维</span>        <span class="token comment" spellcheck="true">//发送邮件给开发人员,ex对象发送给开发人员</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>BusinessException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">doBusinessException</span><span class="token punctuation">(</span>BusinessException ex<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="案例：SSM整合标准开发"><a href="#案例：SSM整合标准开发" class="headerlink" title="案例：SSM整合标准开发"></a>案例：SSM整合标准开发</h5><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h5 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h5><p>首先回顾一下web应用是如何工作的：<figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./Java-SSM%E6%A1%86%E6%9E%B6/image-20230614235159362.png" alt="image-20230614235159362"><figcaption>image-20230614235159362</figcaption></figure></p><p>概念：拦截器是一种动态拦截方法调用的机制</p><p>作用：</p><ul><li>在指定的方法调用前后执行预先设定后的代码</li><li>阻止原始方法的执行</li></ul><p>拦截器与过滤器区别：</p><ul><li>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术</li><li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li></ul><h5 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h5><p>制作拦截器功能类：</p><p>声明拦截器的bean，并实现HandlerInterceptor接口（注意：扫描加载bean）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token comment" spellcheck="true">//定义拦截器类，实现HandlerInterceptor接口</span><span class="token comment" spellcheck="true">//注意当前类必须受Spring容器控制</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProjectInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//原始方法调用前执行的内容</span>    <span class="token comment" spellcheck="true">//返回值类型可以拦截控制的执行，true放行，false终止</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String contentType <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HandlerMethod hm <span class="token operator">=</span> <span class="token punctuation">(</span>HandlerMethod<span class="token punctuation">)</span>handler<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"preHandle..."</span><span class="token operator">+</span>contentType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//原始方法调用后执行的内容</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"postHandle..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//原始方法调用完成后执行的内容</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterCompletion..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>preHandle()方法返回false的话，就不会执行处理器</p></blockquote><p>配置拦截器的执行位置：</p><p>定义配置类，继承WebMvcConfigurationSupport，实现addInterceptor方法（注意：扫描加载配置）<br>添加拦截器并设定拦截的访问路径，路径可以通过可变参数设置多个</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringMvcSupport</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProjectInterceptor projectInterceptor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>ResourceHandlerRegistry registry<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">"/pages/**"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">"/pages/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//配置拦截器</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>projectInterceptor<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">,</span><span class="token string">"/books/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>也可以使用标准接口WebMvcConfigurer简化开发（注意：侵入式较强）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"com.itheima.controller"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableWebMvc</span><span class="token comment" spellcheck="true">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringMvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProjectInterceptor projectInterceptor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProjectInterceptor2 projectInterceptor2<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//配置多拦截器</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>projectInterceptor<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">,</span><span class="token string">"/books/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>projectInterceptor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">,</span><span class="token string">"/books/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="拦截器工作流程分析"><a href="#拦截器工作流程分析" class="headerlink" title="拦截器工作流程分析"></a>拦截器工作流程分析</h5><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230615003003024.png" alt="image-20230615003003024"><figcaption>image-20230615003003024</figcaption></figure></p><h5 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h5><p>前置处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>                        HttpServletResponse response<span class="token punctuation">,</span>                        Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"preHandle..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>参数：</p><ul><li>request：请求对象</li><li>response：响应对象</li><li>handler：被调用的处理器对象，本质上不是一个方法对象，对反射技术中的Method对象进行了再包装</li></ul><p>返回值：返回值为false，被拦截的处理器将不执行</p><p>后置处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>                        HttpServletResponse response<span class="token punctuation">,</span>                        Object handler<span class="token punctuation">,</span>                        ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"postHandle..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>参数：modelAndView，如果处理器执行完成具有返回结果，可以读取到数据与页面信息，并进行调整</p><p>完成后处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>                        HttpServletResponse response<span class="token punctuation">,</span>                        Object handler<span class="token punctuation">,</span>                        Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterCompletion..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>参数：ex：如果处理器执行过程中出现异常现象，可以针对异常情况进行单独处理</p><h5 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h5><p>配置代码见–<strong>入门案例：使用标准接口WebMvcConfigurer简化开发</strong></p><p>多拦截器执行顺序：</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230615004840614.png" alt="image-20230615004840614"><figcaption>image-20230615004840614</figcaption></figure></p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h3><h4 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h4><p>概述：SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><p>Spring缺点：</p><ol><li>配置繁琐</li><li>依赖繁琐</li></ol><p>SpringBoot功能：</p><ol><li>自动配置</li><li>起步依赖</li><li>辅助功能</li></ol><blockquote><p>SpringBoot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</p></blockquote><h4 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h4><p>需求：搭建SpringBoot，定义HelloController.hello()方法，返回“Hello SpringBoot！”</p><p>实现步骤：</p><ol><li>创建Maven项目</li><li>导入SpringBoot起步依赖</li><li>定义Controller</li><li>编写引导类</li><li>启动测试</li></ol><h4 id="SpringBoot起步依赖原理分析"><a href="#SpringBoot起步依赖原理分析" class="headerlink" title="SpringBoot起步依赖原理分析"></a>SpringBoot起步依赖原理分析</h4><p><parent>spring-boot-starter-parent</parent></p><p><dependency>spring-boot-starter-web</dependency></p><h4 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h4><h5 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h5><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（yaml）进行配置：</p><p>properties：<br>server.port&#x3D;8080</p><p>yml：<br>server:<br>port: 8080</p><p>优先级：application.properties &gt; application.yml &gt; application.yaml</p><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>读取配置内容：</p><ol><li>@Value</li><li>Enviroment</li><li>@ConfigurationProperties</li></ol><h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>我们在开发SpringBoot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。Profile功能就是来进行动态配置切换的。</p><p>Profile配置方式：</p><ul><li>多profile文件方式</li><li>yml多文档方式</li></ul><p>Profile激活方式：</p><ul><li><p>配置文件</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616183724539.png" alt="image-20230616183724539" style="zoom: 50%;"><figcaption>image-20230616183724539</figcaption></figure></li><li><p>虚拟机参数</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230616184007279.png" alt="image-20230616184007279" style="zoom: 25%;"><figcaption>image-20230616184007279</figcaption></figure></li><li><p>命令行参数</p><p>java -jar xxx.jar –spring.profiles.active&#x3D;pro</p></li></ul><h5 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h5><p>内部配置加载顺序：</p><p>SpringBoot程序启动时，会从以下位置加载配置文件：</p><ol><li>file:.&#x2F;confog&#x2F;         ：当前项目下的&#x2F;config目录下</li><li>file:.&#x2F;                       ：当前项目的根目录</li><li>classpath:&#x2F;config&#x2F;：classpath的&#x2F;config目录</li><li>classpath:&#x2F;             ：classpath的根目录</li></ol><blockquote><p>加载顺序为上文的排列顺序，高优先级配置的属性会生效</p></blockquote><p>外部配置加载顺序：</p><p>通过官网查看外部属性加载顺序：</p><h4 id="SpringBoot整合其他框架"><a href="#SpringBoot整合其他框架" class="headerlink" title="SpringBoot整合其他框架"></a>SpringBoot整合其他框架</h4><h5 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h5><p>实现步骤：</p><ol><li><p>创建SpringBoot工程</p></li><li><p>引入starter-test起步依赖</p></li><li><p>编写测试类</p></li><li><p>添加测试相关注解</p><p>@RunWith(SpringRunner.class)</p><p>@SpringBootTest(classes &#x3D; 启动类.class)</p></li><li><p>编写测试方法</p></li></ol><h5 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h5><p>实现步骤：</p><ol><li>创建SpringBoot工程</li><li>引入redis起步依赖</li><li>配置redis相关属性</li><li>注入RedisTemplate模板</li><li>编写测试方法，进行测试</li></ol><h5 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h5><p>实现步骤：</p><ol><li>创建SpringBoot工程</li><li>引入MyBatis起步依赖，添加MySQL驱动</li><li>编写DataSource和MyBatis相关配置</li><li>定义表和实体类</li><li>编写dao和mapper文件&#x2F;纯注解开发</li><li>测试</li></ol><h3 id="SpringBoot高级"><a href="#SpringBoot高级" class="headerlink" title="SpringBoot高级"></a>SpringBoot高级</h3><h4 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h4><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>Codition是在Spring4.0增加的条件判断功能，通过这个功能可以实现选择性的创建Bean操作</p><blockquote><p>思考：SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如何知道要创建RedisTemplate的？</p></blockquote><p>需求：在Spring的IOC容器中有一个User的Bean，现要求：</p><ol><li>导入Jedis坐标后，加载该Bean，没导入，则不加载</li><li>将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定</li></ol><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./Java-SSM%E6%A1%86%E6%9E%B6/image-20230618004958445.png" alt="image-20230618004958445"><figcaption>image-20230618004958445</figcaption></figure></p><h5 id="Enable-注解"><a href="#Enable-注解" class="headerlink" title="@Enable*注解"></a>@Enable*注解</h5><p>SpringBoot中提供了很多Enable开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载</p><p>@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4种用法：</p><ol><li>导入Bean</li><li>导入配置类</li><li>导入ImportSelector实现类，一般用于加载配置文件中的类</li><li>导入ImportBeanDefinitionRegistrar实现类</li></ol><h5 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h5><p>@EnableAutoConfiguration注解内部使用@Import（AutoConfigurationImportSelector.class）来加载配置类</p><p>配置文件位置：META-INF&#x2F;spring.factories，该配置文件种定义了大量的配置类，当SpringBoot应用启动时，会自动加载这些配置类，初始化Bean</p><p>并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean</p><h5 id="自定义配置案例"><a href="#自定义配置案例" class="headerlink" title="自定义配置案例"></a>自定义配置案例</h5><p>需求：自定义redis-starter。要求当导入redis坐标时，SpringBoot自动创建Jedis的Bean</p><p>实现步骤：</p><ol><li>创建redis-spring-boot-autoconfigure模块</li><li>创建redis-spring-boot-starter模块，依赖redis-spring-boot-autoconfigure的模块</li><li>在redis-spring-boot-autoconfigure模块中初始化Jedis的Bean。并定义META-INF&#x2F;spring.factories文件</li><li>在测试模块中引入自定义的redis-starter依赖，测试获取Jedis的Bean，操作redis</li></ol><h4 id="SpringBoot监听机制"><a href="#SpringBoot监听机制" class="headerlink" title="SpringBoot监听机制"></a>SpringBoot监听机制</h4><p>SpringBoot的监听机制，其实是对Java提供的事件监听机制的封装</p><p>Java中的事件监听机制定义了以下几个角色：</p><ol><li>事件：Event，继承java.util.EventObject类的对象</li><li>事件源：Source，任意对象Object</li><li>监听器：Listener，实现java.util.EventListener接口的对象</li></ol><p>SpringBoot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作：</p><p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p><h4 id="SpringBoot启动流程分析"><a href="#SpringBoot启动流程分析" class="headerlink" title="SpringBoot启动流程分析"></a>SpringBoot启动流程分析</h4><h4 id="SpringBoot监控"><a href="#SpringBoot监控" class="headerlink" title="SpringBoot监控"></a>SpringBoot监控</h4><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控情况、Bean加载情况、配置属性、日志信息等</p><p>使用步骤：</p><ol><li><p>导入依赖坐标：</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>访问–<a class="link" href="http://localhost:8080/actuator">http://localhost:8080/actuator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ol><p>图形化监控–Spring Boot Admin</p><p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序<br>Spring Boot Admin有两个角色，客户端（Client）和服务端（Server）<br>应用程序作为Spring Boot Admin Client向Spring Boot Admin Server注册<br>Spring Boot Admin Server的UI界面将Spring Boot Admin Client的Actuator Endpoint的一些监控信息展示</p><p>使用步骤：</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230620234404139.png" alt="image-20230620234404139" style="zoom:67%;"><figcaption>image-20230620234404139</figcaption></figure>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/Java%E5%BC%80%E5%8F%91/">Java开发</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/java/">java</category>
      
      
      <comments>http://xuanyin02.github.io/2023/06069152.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker+K8S</title>
      <link>http://xuanyin02.github.io/2023/060663789.html</link>
      <guid>http://xuanyin02.github.io/2023/060663789.html</guid>
      <pubDate>Tue, 06 Jun 2023 06:23:31 GMT</pubDate>
      
      <description>介绍了Docker和K8S的基础知识</description>
      
      
      
      <content:encoded><![CDATA[<p>Docker</p><p>为什么学Docker？</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230606145241038.png" alt="image-20230606145241038"><figcaption>image-20230606145241038</figcaption></figure></p><p>Docker的正式学习</p><p>一、基本概念</p><p>1 概念</p><p>Docker是基于Google公司推出的Golang语言开发而来，基于Linux内核的Cgroups、NameSpace，以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。<br>由于隔离的进程独立于宿主机和其他隔离的进程，也被称之为容器。<br>最初的Docker的基于LXC的，后来取出LXC转而使用自行开发的Libcontainer。<br>Docker被定义为开源的容器引擎，可以方便的对容器进行管理。例如对镜像打包封装，引入Docker Registry对镜像统一管理。<br>利用Docker可以实现开发，测试，生产环境的部署一致性，极大的减少运维成本。</p><p>2 解决的问题：</p><ol><li><p>统一标准</p><p>应用构建</p><p>应用分享</p><p>应用运行</p></li><li><p>资源隔离</p><p>cpu、memory资源隔离与限制</p><p>访问设备隔离与限制</p><p>网络隔离与限制</p><p>用户、用户组隔离限制</p></li></ol><p>2 容器化技术：</p><ol><li>基础镜像MB级别</li><li>创建简单</li><li>隔离性强</li><li>启动速度秒级</li><li>移植和分享方便</li></ol><p>3 架构</p><p>Docker引擎</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230606151205372.png" alt="image-20230606151205372"><figcaption>image-20230606151205372</figcaption></figure></p><p>Docker平台组成</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230606151304523.png" alt="image-20230606151304523"><figcaption>image-20230606151304523</figcaption></figure></p><p>Docker最核心的组件：</p><ul><li>Image镜像，构建容器（应用程序运行所需的环境，打包为镜像文件）</li><li>Container，容器（应用程序就跑在容器中）</li><li>镜像仓库（docker hub）（保存镜像文件，提供上传、下载镜像）作用好比github</li><li>Dockerfile，将你部署项目的操作，写成一个部署脚本，这就是Dockerfile，且该脚本还能够构建出镜像文件</li></ul>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/Docker-K8S/">Docker+K8S</category>
      
      
      <comments>http://xuanyin02.github.io/2023/060663789.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于大数据处理引擎Spark知识的学习</title>
      <link>http://xuanyin02.github.io/2023/051959676.html</link>
      <guid>http://xuanyin02.github.io/2023/051959676.html</guid>
      <pubDate>Fri, 19 May 2023 14:23:10 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;第一章：RDD详解&quot;&gt;&lt;a href=&quot;#第一章：RDD详解&quot; class=&quot;headerlink&quot; title=&quot;第一章：RDD详解&quot;&gt;&lt;/a&gt;第一章：RDD详解&lt;/h3&gt;&lt;h3 id=&quot;1-1-为什么需要RDD&quot;&gt;&lt;a href=&quot;#1-1-为什么需要RDD&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="第一章：RDD详解"><a href="#第一章：RDD详解" class="headerlink" title="第一章：RDD详解"></a>第一章：RDD详解</h3><h3 id="1-1-为什么需要RDD"><a href="#1-1-为什么需要RDD" class="headerlink" title="1.1 为什么需要RDD"></a>1.1 为什么需要RDD</h3><p>分布式计算需要：</p><ul><li>​    分区控制</li><li>​    Shuffle控制</li><li>​    数据存储\序列化\发送</li><li>​    数据计算API  等一系列功能</li></ul><p>这些功能，不能简单的通过Python内置的本地集合对象（如List\字典等）去完成。我们在分布式框架中，需要有一个统一的数据抽象对象，来实现上述分布式计算所需功能。<strong>这个抽象对象，就是RDD</strong>。</p><h3 id="1-2-什么是RDD"><a href="#1-2-什么是RDD" class="headerlink" title="1.2 什么是RDD"></a>1.2 什么是RDD</h3><p>RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，代表一个<strong>不可变、可分区、里面的元素可并行计算</strong>的集合。</p><p><strong>Resilient</strong>：Spark优先把数据放到内存中，如果内存放不下，就会放到磁盘里面，程序进行自动的存储切换<br>在RDD进行转换和动作的时候，会形成RDD的Lineage依赖链，当某一个RDD失效的时候，可以通过重新计算上游的RDD来重新生成丢失的RDD数据。<br>Spark把这个Job执行模型抽象为通用的有向无环图DAG，可以将多Stage的任务串联或并行执行，调度引擎自动处理Stage的失败以及Task的失败<br>Task如果失败会自动进行特定次数的重试，默认重试次数为4<br>Stage如果失败会自动进行特定次数的重试，默认重试次数为4<br>数据分片的高度弹性：可以根据业务的特征，动态调整数据分片的个数，提升整体的应用执行效率</p><p><strong>Distributed</strong>：RDD中的数据是分布式存储的，可用于分布式计算。RDD的数据是跨机器存储的（跨进程）</p><p><strong>Dataset</strong>：一个数据集合，用于存放数据的。List、Dict、Array本地集合（数据全部在一个进程内部）</p><p>不可变：不可变集合，变量的声明使用val</p><p>分区的：集合的数据被划分为很多部分，每部分称为分区Partition</p><p>并行计算：集合中的数据可以被并行的计算处理，每个分区数据被一个task处理</p><h3 id="1-3-RDD的五大特性"><a href="#1-3-RDD的五大特性" class="headerlink" title="1.3 RDD的五大特性"></a>1.3 RDD的五大特性</h3><p>前三个特性每个RDD都具备的，后两个特征是可选的：</p><ol><li>RDD是有分区的</li><li>计算方法都会作用到每一个分片（分区）之上</li><li>RDD之间是有相互依赖的关系的</li><li>KV型RDD可以有分区器</li><li>RDD分区数据的读取会尽量靠近数据所在地</li></ol><h3 id="第二章-RDD编程入门"><a href="#第二章-RDD编程入门" class="headerlink" title="第二章 RDD编程入门"></a>第二章 RDD编程入门</h3><h3 id="第三章-RDD的持久化"><a href="#第三章-RDD的持久化" class="headerlink" title="第三章 RDD的持久化"></a>第三章 RDD的持久化</h3><h4 id="3-1-RDD的数据的过程数据"><a href="#3-1-RDD的数据的过程数据" class="headerlink" title="3.1 RDD的数据的过程数据"></a>3.1 RDD的数据的过程数据</h4><p>RDD之间相互迭代计算（Transformation的转换），当执行开启后，新的RDD的生成，代表老RDD的消失</p><p>RDD的数据是过程数据，只在数据的处理过程中存在，一旦处理完成，就不见了。这个特性可以最大化的利用资源，老旧RDD没用了，就从内存中清理，给后续的计算腾出内存空间</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519230343524.png" alt="image-20230519230343524"><figcaption>image-20230519230343524</figcaption></figure></p><p>为了不重新从rdd1开始构建rdd3，所以要使用rdd的持久化技术</p><h4 id="3-2-RDD-Cache"><a href="#3-2-RDD-Cache" class="headerlink" title="3.2 RDD Cache"></a>3.2 RDD Cache</h4><p>对于上述的场景，肯定要执行优化，优化就是：rdd3如果不消失，那么rdd1-&gt;rdd2-&gt;rdd3这个链条就不会执行2次，或者更多次</p><p>RDD的缓存技术：Spark提供了缓存的API，可以让我们通过调用API，将指定的RDD的数据保留在内存或者硬盘上</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519230515665.png" alt="image-20230519230515665"><figcaption>image-20230519230515665</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519230657165.png" alt="image-20230519230657165"><figcaption>image-20230519230657165</figcaption></figure></p><h4 id="3-3-RDD-CheckPoint"><a href="#3-3-RDD-CheckPoint" class="headerlink" title="3.3 RDD CheckPoint"></a>3.3 RDD CheckPoint</h4><p>CheckPoint技术，也是将RDD的数据，保存起来但是它仅支持硬盘存储</p><p>并且：①它被设计认为是安全的；②不保留血缘关系。</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519230903213.png" alt="image-20230519230903213"><figcaption>image-20230519230903213</figcaption></figure></p><p>Cache（缓存）与CheckPoint的对比：</p><ul><li>​    CheckPoint不管分区数量多少，风险是一样的，缓存分区越多，风险越高</li><li>​    CheckPoint支持写入HDFS，缓存不行，HDFS是高可靠存储，CheckPoint被认为是安全的</li><li>​    CheckPoint不支持内存，缓存可以，缓存如果写内存，性能比CheckPoint要好一些</li><li>​    CheckPoint因为被设计认为是安全的，所以不保留血缘关系，而缓存因为设计上认为不安全，所以保留</li></ul><p>设置CheckPoint第一件事情，选择RDD的保存路径<br>如果是Local模式，可以支持本地文件系统，如果在集群运行，千万要用HDFS<br>Sc.setCheckpointDir(“hdfs:node1:9000&#x2F;out&#x2F;xxx”)<br>用的时候，直接调用checkpoint算子即可：<br>Rdd.checkpoint()</p><h3 id="第四章-Spark案例练习"><a href="#第四章-Spark案例练习" class="headerlink" title="第四章 Spark案例练习"></a>第四章 Spark案例练习</h3><h3 id="第五章-共享变量"><a href="#第五章-共享变量" class="headerlink" title="第五章 共享变量"></a>第五章 共享变量</h3><h4 id="5-1-广播变量"><a href="#5-1-广播变量" class="headerlink" title="5.1 广播变量"></a>5.1 广播变量</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519232155710.png" alt="image-20230519232155710"><figcaption>image-20230519232155710</figcaption></figure></p><p>!!!Executor是进程，进程内资源共享，一个Executor中有两个分区，那这两个分区就可以共享资源。Stu_info_list由Driver发送给每个分区，但是又可以共享，那么Executor中就有了两份相同的资源，造成内存的浪费和网络传输成本的增加。</p><p>解决方案：广播变量<br>使用方式：<br>#1、将本地list标记成广播变量即可<br>Broadcast &#x3D; sc.broadcast(stu_info_list)<br>#2、使用广播变量，从broadcast对象中取出本地list对象即可<br>Value &#x3D; broadcast.value</p><p>#也就是 先放进去broadcast内部，然后从broadcast内部取出来用，中间传输的是broadcast这个对象了<br>#只要中间传输的是broadcast对象，spark就会留意，只会给每个Ececutor发一份了，而不是傻傻的哪个分区要都给</p><h4 id="5-2-累加器"><a href="#5-2-累加器" class="headerlink" title="5.2 累加器"></a>5.2 累加器</h4><p>需求：想要对map算子计算中的数据，进行技术累加，得到全部数据计算完后的累加结果<br>因为我们初始化的count标志从Driver发送给Ececutor是发送的数值，不像指针地址那种</p><h3 id="第六章-Spark内核调度"><a href="#第六章-Spark内核调度" class="headerlink" title="第六章 Spark内核调度"></a>第六章 Spark内核调度</h3><h4 id="6-1-DAG"><a href="#6-1-DAG" class="headerlink" title="6.1 DAG"></a>6.1 DAG</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519232555194.png" alt="image-20230519232555194"><figcaption>image-20230519232555194</figcaption></figure></p><p>DAG：有向无环图。有方向没有形成闭环的一个执行流程图</p><p>一个Action会将前面一串的RDD依赖关系（Transformation）执行，也就是一个Action会产生一个DAG图<br>前面我们写的搜索日志分析案例，3个需求就是3个Action，就产生了3个DAG<br>一个Action会产生一个Job（一个应用程序内的子任务），每一个Job有各自的DAG图<br></p><p>结论：Job和Action<br>1个Action会产生1个DAG，如果代码中有3个Action就产生3个DAG<br>一个Action会产生一个DAG，会在程序运行中产生一个Job<br>所以：1个Action &#x3D; 1个DAG &#x3D; 1个Job<br>如果一个代码中，写了3个Action，那么这个代码运行起来产生3个Job，每个Job有自己的DAG<br></p><p>一个代码运行起来，在Spark中称之为：Application<br>层级关系：1个Application中，可以有多个Job，每一个Job内含一个DAG，同时每一个Job都是由一个Action产生的</p><p>DAG是Spark代码的逻辑执行图，这个DAG的最终作用是：为了构建物理上的Spark详细执行计划而生，所以，由于Spark是分布式（多分区）的，那么DAG和分区之间也是有关联的</p><h4 id="6-2-DAG的宽窄依赖和阶段划分"><a href="#6-2-DAG的宽窄依赖和阶段划分" class="headerlink" title="6.2 DAG的宽窄依赖和阶段划分"></a>6.2 DAG的宽窄依赖和阶段划分</h4><p>宽窄依赖：</p><p>在Spark RDD前后之间的关系，分为：窄依赖、 宽依赖<br>窄依赖：父RDD的一个分区，全部将数据发给子RDD的一个分区<br>宽依赖：父RDD的一个分区，将数据发给子RDD的多个分区<br>宽依赖还有一个别名：shuffle</p><p>阶段划分：</p><p>对于Spark来说，会根据DAG，按照宽窄依赖，划分不同的DAG阶段<br>划分依据：从后往前，遇到宽依赖，就分出一个阶段，称之为stage<br>在stage的内部，一定都是：窄依赖</p><h4 id="6-3-内存迭代运算"><a href="#6-3-内存迭代运算" class="headerlink" title="6.3 内存迭代运算"></a>6.3 内存迭代运算</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234250136.png" alt="image-20230519234250136"><figcaption>image-20230519234250136</figcaption></figure></p><p>![image-20230519233246978](.&#x2F;%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8ESpark%E7%9F%A5%E8%AF%86%E7%9A%84%E5%AD%A6%E4%B9%A0&#x2F;image-20230519233246978.png</p><p>​    <figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234238064.png" alt="image-20230519234238064"><figcaption>image-20230519234238064</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234346576.png" alt="image-20230519234346576"><figcaption>image-20230519234346576</figcaption></figure></p><h4 id="6-4-Spark并行度"><a href="#6-4-Spark并行度" class="headerlink" title="6.4 Spark并行度"></a>6.4 Spark并行度</h4><p>Spark的并行：在同一时间内，有多少个task在同时运行<br>并行度：并行能力的设置<br>比如设置并行度为6，其实就是要6个task并行在跑<br>在有了6个task并行的前提下，rdd的分区就被规划成6个分区了</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234535771.png" alt="image-20230519234535771"><figcaption>image-20230519234535771</figcaption></figure></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234559444.png" alt="image-20230519234559444"><figcaption>image-20230519234559444</figcaption></figure></p><h4 id="6-5-Spark任务调度"><a href="#6-5-Spark任务调度" class="headerlink" title="6.5 Spark任务调度"></a>6.5 Spark任务调度</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230519234628606.png" alt="image-20230519234628606"><figcaption>image-20230519234628606</figcaption></figure></p><p>DAG调度器：工作内容：将逻辑的DAG图进行处理，最终得到逻辑上的Task划分</p><p>Task调度器：工作内容：基于DAG调度器的产出，来规划这些逻辑的task，应该在哪些物理的executor上运行，以及监控管理它们的运行</p><p>Spark架构体系</p><p>StandAlone模式是spark⾃带的集群运⾏模式，不依赖其他的资源调度框架，部署起来简单。<br>StandAlone模式⼜分为client模式和cluster模式，本质区别是Driver运⾏在哪⾥，如果Driver运⾏在SparkSubmit进程中就是Client模式，如果Driver运⾏在集群中就是Cluster模式。</p><p>standalone client模式</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8ESpark%E7%9F%A5%E8%AF%86%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230519224936208.png" alt="image-20230519224936208"><figcaption>image-20230519224936208</figcaption></figure></p><p>standalone cluster模式</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8ESpark%E7%9F%A5%E8%AF%86%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230519225011812.png" alt="image-20230519225011812"><figcaption>image-20230519225011812</figcaption></figure></p><p>Spark On YARN cluster模式</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="/./%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8ESpark%E7%9F%A5%E8%AF%86%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230519225828449.png" alt="image-20230519225828449"><figcaption>image-20230519225828449</figcaption></figure></p><ol><li>client向ResourceManager申请资源，返回一个application ID</li><li>client上传spark jars下面的jar包、自己写的jar包和配置</li><li>ResourceManager随机找一个资源充足的NodeManager</li><li>然后通过RPC让NodeManager从HDFS上下载jar包和配置，启动ApplicationMaster</li><li>ApplicationMaster向ResourceManager申请资源</li><li>ResourceManager中的调度器找到符合条件的NodeManager，将NodeManager的信息返回给ApplicationMaster</li><li>ApplicationMaster跟返回的NodeManager进行通信</li><li>NodeManager从HDFS下载依赖</li><li>NodeManager启动Executor</li><li>Executor启动之后反向向ApplicationMaster [Driver]注册</li></ol>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/spark/">spark</category>
      
      
      <comments>http://xuanyin02.github.io/2023/051959676.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面试常见问题</title>
      <link>http://xuanyin02.github.io/2023/05188946.html</link>
      <guid>http://xuanyin02.github.io/2023/05188946.html</guid>
      <pubDate>Thu, 18 May 2023 13:41:38 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h3&gt;&lt;h4 id=&quot;Java语言特点&quot;&gt;&lt;a href=&quot;#Java语言特点&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ul><li>Java为纯面向对象的语言；</li><li>具有平台无关性；</li><li>Java为解释型语言；</li><li>Java提供了很多内置库。如对多线程支持、对网络通信支持；</li><li>Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制。</li></ul><h4 id="简述Java访问修饰符"><a href="#简述Java访问修饰符" class="headerlink" title="简述Java访问修饰符"></a>简述Java访问修饰符</h4><ul><li>default：默认访问修饰符，在同一包内可见</li><li>private：用private修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用，不能修饰外部类</li><li>protected：对同一包内的类和所有的子类可见，不能修饰外部类</li><li>public：对所有类可见</li></ul><h4 id="构造函数、成员变量、代码块初始化顺序"><a href="#构造函数、成员变量、代码块初始化顺序" class="headerlink" title="构造函数、成员变量、代码块初始化顺序"></a>构造函数、成员变量、代码块初始化顺序</h4><p>顺序：静态成员变量 -&gt; 静态代码块 -&gt; 非静态成员变量 -&gt; 非静态代码块 -&gt; 构造函数<br>详细顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数</p><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><ul><li><p><strong>封装</strong>：利用抽象数据类型（类）将数据（属性）和基于数据的操作（基于属性的方法）绑定在一起，使其构成一个不可分隔的独立实体。</p></li><li><p><strong>继承</strong>：子类继承自父类，从而获得父类非private的属性和方法，且子类可以修改或新增新的方法<br>继承应该遵循里氏替换原则<br>那么什么是里氏替换原则呢？：子类对象的行为应该与父类对象期望的行为一致（子类对象的行为造成的结果不能出现父类对象方法中未出现的结果）<br>父类引用指向子类对象 称为向上转型<br>父类 父类引用 &#x3D; new 子类()  –》 Animal animal &#x3D; new Cat()</p></li><li><p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力（多态就是同一个接口，使用不同实例而执行不同的操作）</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230525232630820.png" alt="image-20230525232630820" style="zoom:50%;"><figcaption>image-20230525232630820</figcaption></figure><p>分为编译时多态和运行时多态<br>编译时多态主要指方法的重载<br>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件：继承、重写、向上转型<br>多态：多种不同形态<br>如：ArrayList是List的一种形态；LinkedList也是List的一种形态</p></li></ul><h4 id="接口和抽象类的相同点和不同点"><a href="#接口和抽象类的相同点和不同点" class="headerlink" title="接口和抽象类的相同点和不同点"></a>接口和抽象类的相同点和不同点</h4><p>相同点：</p><ul><li>都不能被实例化</li><li>接口的实现类或抽象类需实现接口或抽象类中相应的方法才能被实例化</li></ul><p>不同点：</p><ul><li>接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现</li><li>实现接口的关键字为 implements，继承的抽象类的关键字类 extends。一个类可以实现多个接口，只能继承一个抽象类</li><li>当子类和父类存在逻辑上的层次结构，体现的是is-a的关系，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，体现为can的关系，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法</li></ul><h4 id="简述内部类及其作用"><a href="#简述内部类及其作用" class="headerlink" title="简述内部类及其作用"></a>简述内部类及其作用</h4><ul><li>成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性</li><li>局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量</li><li>匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量</li><li>静态内部类：类似类的静态成员变量</li></ul><h4 id="Java-语言中关键字-static-的作用是什么"><a href="#Java-语言中关键字-static-的作用是什么" class="headerlink" title="Java 语言中关键字 static 的作用是什么"></a>Java 语言中关键字 static 的作用是什么</h4><ul><li>为某种特定数据类型或对象 分配 与创建对象个数无关的单一的存储空间。</li><li>使得某个方法或属性 与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。</li></ul><p>具体而言 static 又可分为 4 种使用方式：</p><ol><li>修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。</li><li>修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。</li><li>修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。</li><li>修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。</li></ol><h4 id="为什么String不可变"><a href="#为什么String不可变" class="headerlink" title="为什么String不可变"></a>为什么String不可变</h4><p>String内部使用char数组value[ ]存储数据，该数组被声明为final，这意味着value数组初始化之后，不能再引用其他数组，并且String内部没有改变value数组的方法，因此String不可变。</p><p>不可变的好处：</p><ul><li>String作为HashMap的key。不可变的特性可以使得hash值也不可变。</li><li>节省空间，字符串常量存储在JVM的字符串池中可以被用户共享。</li><li>安全性，String作为参数，String不可变可以保证参数不变。</li><li>线程安全。</li></ul><h4 id="x3D-x3D-和-equals的区别"><a href="#x3D-x3D-和-equals的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals的区别"></a>&#x3D;&#x3D; 和 equals的区别</h4><p>&#x3D;&#x3D;对比的是栈中的值，比较基本类型，比较的是值；比较引用类型，比较的是堆中的内存地址</p><p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是内存地址，另外重写了equlas后，也必须重写hashcode()方法</p><h4 id="简述Object类常用方法"><a href="#简述Object类常用方法" class="headerlink" title="简述Object类常用方法"></a>简述Object类常用方法</h4><ul><li>hashCode：通过对象计算出散列码。用于map型或 equals方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。</li><li>equals：判断两个对象是否一致。需保证equals方法相同对应的对象hashCode也相同。</li><li>toString：用字符串表示该对象。</li><li>clone：深拷贝一个对象。</li></ul><h4 id="简述Java异常的分类"><a href="#简述Java异常的分类" class="headerlink" title="简述Java异常的分类"></a>简述Java异常的分类</h4><p>Java异常分为Error（程序无法处理的错误）和Exception（程序本身可以处理的异常）。这两个异常均继承Throwable。</p><p>Error常见的有 StackOverFlowError、OutOfMempryError等。</p><p>Exception可分为运行时和非运行时异常。运行时异常可以利用try catch进行处理，也可不处理，非运行时异常必须处理。</p><p>出现在Java程序中的finally代码块是否一定会执行</p><p>当遇到下面情况不会执行：</p><ul><li>当程序在进入try语句块之前就出现异常时会直接结束</li><li>当程序在try快中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码</li></ul><h4 id="final、finally-和-finalize-的区别是什么"><a href="#final、finally-和-finalize-的区别是什么" class="headerlink" title="final、finally 和 finalize 的区别是什么"></a>final、finally 和 finalize 的区别是什么</h4><ul><li>final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承</li><li>finally 作为异常处理的一部分，只能在 try&#x2F;catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下</li><li>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存</li></ul><h4 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h4><p>Java反射机制是在运行状态中，对于任意一个类，都能知道这个类的属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为Java的反射机制。</p><p>如何通过反射获得x类的class对象</p><ol><li>x.class</li><li>x.getClass()</li><li>Class.foeName(“类名”)</li></ol><h4 id="序列化是什么"><a href="#序列化是什么" class="headerlink" title="序列化是什么"></a>序列化是什么</h4><p>序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、<a class="link" href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象</p><h4 id="Concurrenthashmap的解析"><a href="#Concurrenthashmap的解析" class="headerlink" title="Concurrenthashmap的解析"></a>Concurrenthashmap的解析</h4><p>Concurrenthashmap是Java中线程安全的Map实现，它允许多个线程同时对Map进行读写操作，而不会导致数据不一致或者其他线程安全问题。它的主要特点包括：</p><ol><li>分段锁设计：Concurrenthashmap将整个Map分为多个 segment，每个segment都维护着一个独立的哈希表。在读写时，只需要锁定对应的segment，不需要锁定整个Map，从而提高了并发度。</li><li>基于CAS算法的并发控制：Concurrenthashmap的put()、get()、remove()等操作都是通过CAS实现的。在put()操作中，如果两个线程同时插入了同一个key，只有一个线程的操作会成功，另一个线程的操作会失败，从而保证了数据的正确性。</li><li>支持高并发读操作：Concurrenthashmap的读操作不需要锁定Map，多个线程可以同时对Map进行读操作，不会出现并发安全问题。</li><li>空间动态调整：Concurrenthashmap支持动态扩容和收缩，可以根据当前Map中的数据量自动调整容量。</li><li>不保证Map中的数据是按照插入顺序或者其他顺序排列的，因此不适合用于有序数据的存储和查询。</li></ol><h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><p>1、底层数据结构<br>ArrayList底层采用数组实现，因此支持随机访问，可以通过下标索引访问元素，时间复杂度为O(1)。但是在插入和删除操作时，需要移动后面的元素，时间复杂度为O(n)。<br>LinkedList底层采用双向链表实现，因此插入和删除操作只需要改变相邻节点的指针，时间复杂度为O(1)，但是随机访问需要遍历链表，时间复杂度为O(n)。</p><p>2、空间占用<br>ArrayList的内部是一个数组，当元素个数不足数组容量时，会浪费一部分内存空间。而LinkedList每个元素需要额外的空间来存储前后节点的指针，因此会占用更多的内存空间。</p><p>3、迭代器性能<br>在迭代操作时，ArrayList使用普通迭代器或增强for循环的性能比LinkedList更优。这是因为ArrayList的数据存储在连续的内存中，迭代时可以直接访问内存，而LinkedList需要通过遍历链表来访问每个元素。</p><p>4、使用场景<br>ArrayList适用于随机访问比较多，插入和删除操作较少的场景，例如缓存、排序、搜索等。而LinkedList适用于插入和删除操作较多，随机访问较少的场景，例如队列、栈等。</p><h4 id="Collection-和-Collections-有什么区别"><a href="#Collection-和-Collections-有什么区别" class="headerlink" title="Collection 和 Collections 有什么区别"></a>Collection 和 Collections 有什么区别</h4><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如List、Set等</li><li>Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list)；提供的反转方法：Collections.reverse(list)。</li></ul><h3 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h3><ul><li><p>IoC（Inversion of Control）控制反转<br>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这种思想称为控制反转<br>Spring技术对IOC思想进行了实现<br>Spring提供了一个容器，称为IoC容器（系统架构中的Core Container），用来充当IoC思想的“外部“<br>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中被称为Bean</p></li><li><p>DI (Dependency Injection) 依赖注入<br>在容器中建立Bena与Bean之间的依赖关系的整个过程,称为依赖注入</p></li><li><p>AOP（Aspect Oriented Programming）面向切面编程<br>AOP 的实现方式是通过动态代理或字节码操作，在代码运行期间动态地将切面织入到目标对象的方法执行过程中，从而实现对目标对象方法的增强。</p></li></ul><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><h4 id="数据库事务四大特性"><a href="#数据库事务四大特性" class="headerlink" title="数据库事务四大特性"></a>数据库事务四大特性</h4><ol><li>原子性：事务中的所有操作要么全部完成，要么全部不完成，不会只完成其中的一部分操作。如果一个操作失败，整个事务将被回滚到事务开始前的状态，所有的操作都将被撤销。</li><li>一致性：事务执行前后，数据库的状态必须保持一致。如果事务执行后，数据库的状态不符合预期，事务将被回滚到事务开始前的状态，以保证数据库的一致性。</li><li>隔离性：事务执行的过程中，对其他事务是隔离的。即每个事务都认为自己是唯一在操作数据库的事务，不受其他事务的干扰。事务隔离级别包括读未提交、读已提交、可重复读和串行化，不同的隔离级别会影响并发性能和数据的一致性。</li><li>持久性：事务完成后，对数据库的修改必须永久保存在数据库中，即使出现了系统故障或断点等情况，也不能丢失，为了实现持久性，数据库通常使用日志来记录所有的事务操作，以便在系统故障恢复后恢复数据。</li></ol><h4 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h4><p>首先解释一下幻读和不可重复读</p><p><strong>幻读</strong>是指在同一个事务内，第一次查询某个范围内的数据时，没有查询到某些行，但是在该事务内后续再次查询同一范围内的数据时，却发现有新的数据行被查到，就像是出现了幻觉一样，因此称之为“幻读”。</p><p><strong>不可重复读</strong>是指在同一个事务内，多次读取同一个数据的结果不一样</p><ul><li>读未提交：最低级别，事务可以读取其他事务未提交的数据，也就是脏读。虽然可以提高并发性能，但是会导致数据的不一致，一般不建议使用。</li><li>读已提交：事务只能读取其他事务已提交的数据，避免了脏读，但是可能出现不可重复度和幻读的问题。</li><li>可重复读：在同一个事务内，多次读取同一个数据的结果都是一样的，不会出现不可重复读的问题。但是可能会出现幻读的问题，即在同一个事务内，一个范围内的数据记录被其他事务修改或删除。</li><li>串行化：最高级别，事务之间相互完全隔离，每个事务都像是在独立的系统中执行，避免了所有并发问题，但是对系统性能影响比较大。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP 是一种可靠的、面向连接的协议，它需要在客户端和服务器之间建立连接，保证数据能够准确、及时地传输。而 TCP 建立连接的方式就是通过三次握手（Three-way Handshake）来完成的。</p><ol><li>客户端向服务器发送 SYN 请求（SYN &#x3D; Synchronize Sequence Numbers），表示客户端想要建<br>立连接。这时，客户端会随机生成一个起始序列号（Sequence Number）x，并将 SYN 标志位置<br>为 1，同时等待服务器的响应。</li><li>服务器收到客户端的 SYN 请求后，会回复一个 SYN+ACK（ACK &#x3D; Acknowledgment）的响应，表<br>示服务器已经接受了客户端的请求，并且想要建立连接。这时，服务器会随机生成一个起始序<br>列号 y，并将 SYN 和 ACK 标志位置为 1，确认号（Acknowledgment Number）设置为 x+1，同时<br>等待客户端的响应。</li><li>客户端收到服务器的 SYN+ACK 响应后，会发送一个 ACK 确认响应，表示客户端已经接受了服务<br>器的请求，并且可以开始发送数据了。这时，客户端会将确认号设置为 y+1，表示客户端已经<br>收到了服务器的响应，连接建立成功。</li></ol><h3 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h3><ol><li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式通过对象的创建与使用分离，从而使代码更加灵活、可扩展，常用于创建对象复杂、种类繁多的场景。</li><li>单例模式：确保一个类只有一个实例，并提供全局访问点。单例模式通过限制一个类只能被实例化一次，从而避免了资源的浪费和竞争条件的产生，常用于需要全局唯一实例的场景。</li><li>观察者模式：定义对象之间一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖它的对象都得到通知并自动更新。观察者模式通过松散耦合的方式，将观察者与被观察者分离，从而使对象之间的关系更加灵活、可扩展。</li><li>装饰器模式：动态地将责任附加到对象上，扩展对象的功能。装饰器模式通过递归组合的方式，使对象可以被无限层次地装饰，从而实现动态地添加、修改、删除对象的功能。</li><li>模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法模式通过定义一个模板方法，将算法的骨架和具体的实现分离，从而使算法可以在不同的场景下得到重复利用。</li></ol>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/java/">java</category>
      
      
      <comments>http://xuanyin02.github.io/2023/05188946.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据仓库建模理论</title>
      <link>http://xuanyin02.github.io/2023/051846990.html</link>
      <guid>http://xuanyin02.github.io/2023/051846990.html</guid>
      <pubDate>Thu, 18 May 2023 01:56:02 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;第1章-数据仓库概述&quot;&gt;&lt;a href=&quot;#第1章-数据仓库概述&quot; class=&quot;headerlink&quot; title=&quot;第1章   数据仓库概述&quot;&gt;&lt;/a&gt;第1章   数据仓库概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-数据仓库概念（Data-Warehouse）&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="第1章-数据仓库概述"><a href="#第1章-数据仓库概述" class="headerlink" title="第1章   数据仓库概述"></a>第1章   数据仓库概述</h3><h4 id="1-1-数据仓库概念（Data-Warehouse）"><a href="#1-1-数据仓库概念（Data-Warehouse）" class="headerlink" title="1.1 数据仓库概念（Data Warehouse）"></a>1.1 数据仓库概念（Data Warehouse）</h4><p>数据仓库是一个为数据分析而设计的企业级数据管理系统。<br>是面向主题的、集成的、稳定的和时变的数据集合。<br>输入数据：业务数据，用户行为数据、爬虫数据。<br>数据仓库，将各个异构的数据源数据库的数据统一管理起来，并且完成了质量较差的数据的剔除、格式转换等预处理操作，最终按照一种合理的建模方式来完成源数据组织形式的转变，为企业<strong>制定决策，提供数据支持</strong>。可以帮助企业<strong>改进业务流程、提高产品质量</strong>等。</p><h4 id="1-2-数据仓库核心架构"><a href="#1-2-数据仓库核心架构" class="headerlink" title="1.2 数据仓库核心架构"></a>1.2 数据仓库核心架构</h4><ul><li>原始数据层–ODS（ODSàOperation Data Store）：存放未经过处理的原始数据，结构上与源系统保持一致，是数据仓库的数据准备区。</li><li>明细数据层–DWD（DWDàData Warehouse Detail）：基于维度建模理论进行构建，存放维度模型中的事实表，保存各业务过程中最小粒度的操作记录。</li><li>公共维度层–DIM（DIMàDimension）：基于维度建模理论进行构建，存放维度模型中的维度表，保存一致性维度信息。</li><li>汇总数据层–DWS（DWSàData Warehouse Summary）：基于上层的指标需求，以分析的主题对象作为建模驱动，构建公共统计粒度的汇总表。</li><li>数据应用层–ADS（ADSàApplication Data Service）：存放各项统计指标结果。</li></ul><h4 id="1-3-数据仓库与数据库的区别"><a href="#1-3-数据仓库与数据库的区别" class="headerlink" title="1.3 数据仓库与数据库的区别"></a>1.3 数据仓库与数据库的区别</h4><ol><li>数据库是面向事务的设计，数据仓库是面向主题设计的</li><li>数据库一般存储业务数据，数据仓库存储的一般是历史数据</li><li>数据库设计是避免冗余，符合业务应用，但是不符合分析。数据仓库在设计是有意引入冗余，依照分析需求，分析维度、分析指标进行设计</li><li>数据库是为捕获数据而设计的，数据仓库是为分析数据而设计</li></ol><h3 id="第2章-数据仓库建模概述"><a href="#第2章-数据仓库建模概述" class="headerlink" title="第2章   数据仓库建模概述"></a>第2章   数据仓库建模概述</h3><h4 id="2-1-数据仓库建模意义"><a href="#2-1-数据仓库建模意义" class="headerlink" title="2.1 数据仓库建模意义"></a>2.1 数据仓库建模意义</h4><p>数据模型就是数据组织和存储的方法，它强调从业务、数据存取和使用角度合理存储数据。只有将数据有序的组织和存储起来之后，数据才能得到高性能、低成本、高效率、高质量的使用。</p><h4 id="2-2-数据仓库模型–ER模型"><a href="#2-2-数据仓库模型–ER模型" class="headerlink" title="2.2 数据仓库模型–ER模型"></a>2.2 数据仓库模型–ER模型</h4><p><strong>ER模型</strong>：用实体关系模型来描述企业业务，并用规范化（减少数据冗余，增强数据的一致性）的方式表示出来，在范式理论上符合3NF</p><ul><li>实体关系模型：实体关系模型将复杂的数据抽象为两个概念——实体和关系。实体表示一个对象，例如学生、班级，关系是指两个实体之间的关系，例如学生和班级之间的从属关系。</li><li>三范式：第一范式1NF：属性不可切割；第二范式2NF：不能存在“部分函数依赖”；第三范式3NF：不能存在传递函数依赖。</li></ul><blockquote><p>这种模型方法的出发点是整合数据，其目的是将整个企业的数据进行组合和合并，并进行规范处理，减少数据冗余性，保证数据的一致性（会产生很多表）。这种模型并不适合直接用于分析统计</p></blockquote><h4 id="2-3-数据仓库模型–维度模型"><a href="#2-3-数据仓库模型–维度模型" class="headerlink" title="2.3 数据仓库模型–维度模型"></a>2.3 数据仓库模型–维度模型</h4><p><strong>维度模型</strong>：将复杂的业务通过<strong>事实</strong>和<strong>维度</strong>两个概念进行呈现，事实通常对应业务过程，而维度通常对应业务过程发生时所处的环境。<br><strong>注</strong>：业务过程可以概括为一个个不可拆分的行为事件，例如电商交易中的下单，取消订单，付款，退单等，都是业务过程。</p><p>下图为一个典型的维度模型，其中<strong>位于中心的SalesOrder为事实表</strong>，其中保存的是下单这个业务过程的所有记录。位于周围每张表都是维度表，包括Date（日期），Customer（顾客），Product（产品），Location（地区）等，这些维度表就组成了每个订单发生时所处的环境，即何人、何时、在何地下单了何种产品。从图中可以看出，模型相对清晰、简洁。</p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230518104312602.png" alt="image-20230518104312602" style="zoom:50%;"><figcaption>image-20230518104312602</figcaption></figure><blockquote><p>维度建模以数据分析作为出发点，为数据分析服务，因此它关注的重点是用户如何更快的完成需求分析以及如何实现较好的大规模复杂查询的响应性能</p></blockquote><h3 id="第3章-维度建模理论之事实表"><a href="#第3章-维度建模理论之事实表" class="headerlink" title="第3章 维度建模理论之事实表"></a>第3章 维度建模理论之事实表</h3><p>事实表（“细长”：列比较少、行比较多，且行的增速快）作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计。其包含与该业务过程的维度引用（维度表外键）以及该业务过程的度量（通常是可累加的数字类型字段）</p><h4 id="3-1-事务型事实表"><a href="#3-1-事务型事实表" class="headerlink" title="3.1 事务型事实表"></a>3.1 事务型事实表</h4><p><strong>概述</strong>：事务型事实表用来记录各业务过程，它保存的是各业务过程的原子操作事件，即最细粒度（粒度是指事实表中一行数据所表达的业务细节程度）的操作事件，可用于分析与各业务过程相关的各项统计指标</p><p><strong>设计流程</strong>：选择业务过程–&gt;声明粒度–&gt;确定维度–&gt;确定事实</p><ul><li><p>选择业务过程：挑选需要的业务，一个业务过程对应一张事务型事实表</p><p>可以确定有哪些事务型事实表</p></li><li><p>声明粒度：精确定义每张事务型事实表的每行数据表示什么</p><p>可以确定每张事务型事实表的每行数据是什么</p></li><li><p>确定维度：确定与每张事务型事实表相关的维度有哪些</p><p>可以确定每张事务型事实表的维度外键</p></li><li><p>确定事实：“事实”，指的是每个业务过程的度量值（通常是可累加的数字类型的值，例如：次数、个数、件数、金额等）</p><p>可以确定每张事务型事实表的度量值字段</p></li></ul><h4 id="3-2-周期型事实表"><a href="#3-2-周期型事实表" class="headerlink" title="3.2 周期型事实表"></a>3.2 周期型事实表</h4><p><strong>概述</strong>：周期快照事实表以具有规律性的、可预见的时间间隔来记录事实，主要用于分析一些存量型（例如商品库存，账户余额）或者状态型（空气温度，行驶速度）指标。</p><h4 id="3-3-累计型事实表"><a href="#3-3-累计型事实表" class="headerlink" title="3.3 累计型事实表"></a>3.3 累计型事实表</h4><p><strong>概述</strong>：累计快照事实表是基于一个业务流程中的<strong>多个关键业务过程</strong>联合处理而构建的事实表，如交易流程中的下单、支付、发货、确认收货业务过程。</p>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">数据仓库</category>
      
      
      <comments>http://xuanyin02.github.io/2023/051846990.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hadoop面试常见问题</title>
      <link>http://xuanyin02.github.io/2023/05169473.html</link>
      <guid>http://xuanyin02.github.io/2023/05169473.html</guid>
      <pubDate>Tue, 16 May 2023 08:26:48 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;一-什么是Hadoop？&quot;&gt;&lt;a href=&quot;#一-什么是Hadoop？&quot; class=&quot;headerlink&quot; title=&quot;一 什么是Hadoop？&quot;&gt;&lt;/a&gt;一 什么是Hadoop？&lt;/h4&gt;&lt;p&gt;Hadoop是一个开源的分布式计算平台，可以处理大规模数据集</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="一-什么是Hadoop？"><a href="#一-什么是Hadoop？" class="headerlink" title="一 什么是Hadoop？"></a>一 什么是Hadoop？</h4><p>Hadoop是一个开源的分布式计算平台，可以处理大规模数据集。它由两个核心组件组成：HDFS文件系统 和 MapReduce计算框架。</p><h4 id="二-Hadoop的优点是什么？"><a href="#二-Hadoop的优点是什么？" class="headerlink" title="二 Hadoop的优点是什么？"></a>二 Hadoop的优点是什么？</h4><p>  可以处理大规模数据集，支持PB级别的数据存储和处理</p><p>  可以在廉价的硬件上运行，降低了成本</p><p>  可以通过数据冗余和自动故障转移来提高可靠性</p><p>  可以通过水平扩展来提高性能</p><p>  可以通过MapReduce计算框架来处理复杂的数据分析任务</p><h4 id="三-Hadoop的工作流程是什么？"><a href="#三-Hadoop的工作流程是什么？" class="headerlink" title="三 Hadoop的工作流程是什么？"></a>三 Hadoop的工作流程是什么？</h4><p>  数据被分割成块并存储在HDFS中</p><p>  MapReduce框架将任务分配给集群中的节点</p><p>  每个节点运行Map任务来处理数据块</p><p>  Map任务输出键值对，这些键值对被shuffle后传递给Reduce任务</p><p>  Reduce任务对键值对进行聚合和处理，并将结果写回HDFS</p><h4 id="四-Hadoop的数据复制是如何实现的？–涉及HDFS数据写入流程"><a href="#四-Hadoop的数据复制是如何实现的？–涉及HDFS数据写入流程" class="headerlink" title="四 Hadoop的数据复制是如何实现的？–涉及HDFS数据写入流程"></a>四 Hadoop的数据复制是如何实现的？–涉及HDFS数据写入流程</h4><p>  Hadoop的数据复制是通过HDFS实现的，当数据被写入HDFS时，它被分成块并复制到多个节点上。默认情况下，每个块会被复制到三个节点上，以提高数据的可靠性。如果一个节点失效，HDFS会自动将数据块复制到其他节点上，以保证数据的可用性。</p><h4 id="五-Hadoop是数据压缩是如何实现的？"><a href="#五-Hadoop是数据压缩是如何实现的？" class="headerlink" title="五 Hadoop是数据压缩是如何实现的？"></a>五 Hadoop是数据压缩是如何实现的？</h4><p>  Hadoop是数据压缩是通过MapReduce框架中的压缩器实现的。压缩器可以在Map和Reduce任务之间压缩和解压缩数据。Hadoop支持多种压缩算法，包括Gzip、Bzip2和Snappy等。</p><h4 id="六-Hadoop的数据安全是如何实现的？"><a href="#六-Hadoop的数据安全是如何实现的？" class="headerlink" title="六 Hadoop的数据安全是如何实现的？"></a>六 Hadoop的数据安全是如何实现的？</h4><p>  Hadoop的数据安全是通过HDFS中的访问控制列表（ACL）和MapReduce框架中的用户身份验证实现的。ACL可以控制对HDFS中文件和目录的访问权限。MapReduce框架可以通过用户身份验证来确保只有授权用户才能运行作业。</p><h4 id="七-Hadoop的调优技巧有哪些？"><a href="#七-Hadoop的调优技巧有哪些？" class="headerlink" title="七 Hadoop的调优技巧有哪些？"></a>七 Hadoop的调优技巧有哪些？</h4><p>  增加节点数：通过增加节点数来提高性能</p><p>  调整块大小：通过调整块大小来提高性能</p><p>  使用压缩：通过使用压缩来减少数据传输量和磁盘空间</p><p>  调整内存和CPU：通过调整内存和CPU来提高性能</p><p>  使用本地磁盘：通过使用本地磁盘来提高性能</p><p>  避免数据倾斜：通过避免数据倾斜来提高性能</p><h4 id="八-Hadoop是常见问题有哪些？"><a href="#八-Hadoop是常见问题有哪些？" class="headerlink" title="八 Hadoop是常见问题有哪些？"></a>八 Hadoop是常见问题有哪些？</h4><p>  数据倾斜：当数据分布不均匀时，会导致某些节点的负载过重，从而影响性能</p><p>  网络带宽限制：当集群中的节点之间的网络带宽不足时，会影响性能</p><p>  硬件故障：当节点硬件故障时，会影响数据可靠性和性能</p><p>  数据丢失：当数据丢失时，会影响数据可靠性和性能</p><p>  安全问题：当Hadoop集群存在安全漏洞时，会影响数据安全性和性能</p><h4 id="九-如何解决Hadoop是常见问题？"><a href="#九-如何解决Hadoop是常见问题？" class="headerlink" title="九 如何解决Hadoop是常见问题？"></a>九 如何解决Hadoop是常见问题？</h4><p>  数据倾斜：通过数据预处理、数据分区和数据复制等方法来避免数据倾斜</p><p>  网络带宽限制：通过增加网络带宽、优化数据传输和调整数据块大小等方法来解决网络带宽限制问题</p><p>  硬件故障：通过使用冗余节点、自动故障转移和备份等方法来提高数据可靠性</p><p>  数据丢失：通过使用数据备份、数据恢复和数据冗余等方法来提高数据可靠性</p><p>  安全问题：通过使用访问控制列表、用户身份验证和加密等方法来提高数据安全性</p><h4 id="十-请说下HDFS读写流程"><a href="#十-请说下HDFS读写流程" class="headerlink" title="十 请说下HDFS读写流程"></a>十 请说下HDFS读写流程</h4><p>HDFS写流程：</p><ol><li>Client发送上传请求，通过RPC与NameNode建立通信，NameNode检查用户是否有上传权限，以及上传的文件是否在HDFS对应的目录下不重名，如果这两者有任意一个不满足，则直接报错，如果两者都满足，则返回给客户端一个可以上传的信息；</li><li>Client根据文件的大小进行切分，默认128M一块，切分完成之后给NameNode发送请求第一个block块上传到哪些服务器上；</li><li>NameNode收到请求之后，根据网络拓扑和机架感知以及副本机制进行文件分配，返回可用的DataNode的地址；</li><li>Cilent收到地址之后与服务器地址列表中的一个节点如A进行通信，本质上就是RPC调用，建立pipeline，A收到请求后会继续调用B，B再调用C，将整个pipeline建立完成，逐级返回Client；</li><li>Cilent开始向A上发送第一个block（先从磁盘读取数据然后放到本地缓存），以packet（数据包，64kb）为单位，A收到一个packet就会发送给B，然后B发送给C，A每传完一个packet就会放入一个应答队列等待应答；</li><li>数据被分隔成一个个的packet数据包在pipeline上依次传输，在pipeline反向传输中，逐个发送ack（命令正确应答），最终由pipeline中第一个DataNode节点A将pipeline ack发送给Cilent；</li><li>当一个block传输完成之后，Client再次请求NameNode上传第二个block，NameNode重新选择三台DataNode给Client。</li></ol><p>HDFS读流程：</p><ol><li>Client向NameNode发送RPC请求，请求block的位置；</li><li>NameNode收到请求之后会检查用户权限以及是否有这个文件，如果都符合，则会视情况返回部分或全部的block列表，对于每个block，NameNode都会返回含有该block副本的DataNode地址；这些返回的DataNode地址，会按照集群拓扑结构得出DataNode与客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离Client近的排靠前；心跳机制中超时汇报的DataNode状态为STALE，这样的排靠后；</li><li>Client选取排序靠前的DataNode来读取block，如果Client本身就是DataNode，那么将从本地直接获取数据（短路读取特性）；</li><li>底层本质上是建立Socket Stream（FSDataInputStream），重复的调用父类DataInputStream的read方法，知道这个块上的数据读取完毕；</li><li>当读完列表的block后，若文件读取还没有结束，Client会继续向NameNode获取下一批的block列表；</li><li>读取完一个block都会进行checksum验证，如果读取DataNode时出现错误，Client会通知NameNode，然后再从下一个拥有该block副本的DataNode继续读；</li><li>read方法是并行的读取block信息，不是一块一块的读取；NameNode只是返回Client请求包含块的DataNode地址，并不是返回请求块是数据；</li><li>最终读取来所有的block会合并成一个完整的最终文件。</li></ol><h4 id="十一-什么是HDFS的安全模式？"><a href="#十一-什么是HDFS的安全模式？" class="headerlink" title="十一 什么是HDFS的安全模式？"></a>十一 什么是HDFS的安全模式？</h4><p>HDFS的安全模式，即HDFS safe mode，是HDFS文件系统的一种特殊状态，在该状态下，HDFS文件系统只接收数据请求，而不接收删除、修改等变更操作，也不能复制底层的block及其副本</p><h4 id="十二-进入安全模式的两种方式"><a href="#十二-进入安全模式的两种方式" class="headerlink" title="十二 进入安全模式的两种方式"></a>十二 进入安全模式的两种方式</h4><p><strong>被动进入</strong>：使用命令—&gt; hdfs dfsadmin -safemode enter</p><p><strong>主动进入</strong>：为了保证整个文件系统的数据一致性&#x2F;整个文件系统不丢失数据</p><ul><li>​    根本原因：</li></ul><ol><li><p>与namenode保持定期心跳的datanode的个数没有达到指定阈值（阈值通过dfs.namenode.safemode.min.datanodes指定）</p></li><li><p>没有足够的block拥有指定的副本数（也就是没达到阈值，最小副本数通过参数dfs.namenode.replication.min指定，阈值通过dfs.namenode.safemode.threshold-pct指定，默认是0.999f）</p></li></ol><blockquote><p>正常情况下，HDFS启动过程中，会主动进入安全模式一段时间，这是HDFS的分布式架构决定的。因为namenode启动成功后，需要等待datanode启动成功并通过心跳汇报datanode上存储的block信息，有足够的block拥有指定的副本数之后，并等待特定时间后（通过参数dfs.namenode.safemode.extensions 30000控制），主动退出安全模式。</p></blockquote><ul><li>直接原因：</li></ul><ol><li>部分datanode启动失败或者因为网络原因与namenode心跳连接失败</li><li>部分datanode节点存储hdfs数据的磁盘卷有损坏，导致存储在该磁盘卷中的数据无法提取</li><li>部分datanode节点存储hdfs数据的磁盘分区空间满，导致存储在该磁盘卷中的数据无法正常读取</li></ol><h4 id="十三-修复问题–修复数据"><a href="#十三-修复问题–修复数据" class="headerlink" title="十三 修复问题–修复数据"></a>十三 修复问题–修复数据</h4><p>比如如果有datanode未成功启动，则尝试修复并启动对应的datanode<br>比如如果有datanode存储hdfs数据的磁盘分区空间满，则尝试扩展磁盘分区空间<br>比如如果有datanode存在存储卷故障，则尝试修复存储卷，如果无法修复则需要替换存储卷（会丢失存储卷上的数据）</p><p>需要注意的是，如果出现了某些datanode彻底损坏无法启动，或某些datanode节点磁盘卷故障彻底无法修复的情况，则这些数据对应的block及block上层的hdfs文件，就被丢失了，就需要补数据（从上游重新拉取数据，或重新运行作业生成数据），也可能无法补。</p><h4 id="十四-HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办？"><a href="#十四-HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办？" class="headerlink" title="十四 HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办？"></a>十四 HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办？</h4><p>  Cilent读取完DataNode上的块之后会进行checksum验证，也就是把客户端读取到本地的块与HDFS上的原始块进行校验，如果发现校验结果不一致，客户端会通知NameNode，然后再从下一个拥有该block副本的DataNode继续读。</p><h4 id="十五-HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办？"><a href="#十五-HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办？" class="headerlink" title="十五 HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办？"></a>十五 HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办？</h4><p>  客户端上传文件时与DataNode建立pipeline管道，管道的正方向是客户端向DataNode发送的数据包，管道反方向是DataNode向客户端发送ack确认，也就是正确接收到数据包之后发送一个已确认接收到的应答。</p><p>  当DataNode突然挂掉了，客户端接收不到这个DataNode发送的ack确认，客户端会通知NameNode，NameNode检查该块的副本与规定的不符，NameNode会通知DataNode去复制副本，并将挂掉的DataNode做下线处理，不再让它参与文件上传与下载。</p><h4 id="十六-NameNode在启动的时候会做哪些操作？"><a href="#十六-NameNode在启动的时候会做哪些操作？" class="headerlink" title="十六 NameNode在启动的时候会做哪些操作？"></a>十六 NameNode在启动的时候会做哪些操作？</h4><p>NameNode数据存储在内存和本地磁盘，本地磁盘数据存储在fsimage镜像文件和edits编辑日志文件。</p><p>首次启动NameNode：</p><ol><li><p>格式化文件系统，为了生成fsimage镜像文件</p></li><li><p>启动NameNode：</p><ol><li>读取fsimage文件，将文件内容加载进内容</li><li>等待DataNode注册与发送block report</li></ol></li><li><p>启动DataNode：</p><ol><li>向NameNode注册</li><li>发送block report</li><li>检查fsimage中记录的块的数量和block report中的块是总数是否相同</li></ol></li><li><p>对文件系统进行操作（创建目录、上传文件、删除文件等）：</p><p>此时内存中已经有文件系统改变的信息，但是磁盘中没有文件系统改变的信息，此时会将这些改变信息写入edits中，edits文件中存储的是文件系统元数据改变的信息</p></li></ol><p>第二次启动NameNode：</p><ol><li>读取fsimage和edits文件；</li><li>将fsimage和edits文件合并成新的fsimage文件；</li><li>创建新的edits文件，内容开始为空；</li><li>启动DataNode</li></ol><h4 id="十七-谈谈对Secondary-NameNode的了解，它的工作机制是怎样的？"><a href="#十七-谈谈对Secondary-NameNode的了解，它的工作机制是怎样的？" class="headerlink" title="十七 谈谈对Secondary NameNode的了解，它的工作机制是怎样的？"></a>十七 谈谈对Secondary NameNode的了解，它的工作机制是怎样的？</h4><p>Secondary NameNode是合并NameNode的edits logs到fsimage文件中。</p><p>它的具体工作机制：</p><ol><li>Secondary NameNode询问NameNode是否需要checkpoint。直接带回结果；</li><li>Secondary NameNode请求执行checkpoint；</li><li>NameNode滚动正在写的edits日志；</li><li>将滚动前的edits日志和fsimage镜像文件拷贝到Secondary NameNode；</li><li>Secondary NameNode加载edits日志和fsimage镜像文件到内存，并合并；</li><li>生成新的镜像文件fsimage.checkpoint；</li><li>拷贝到fsimage.checkpoint到NameNode；</li><li>NameNode将fsimage.checkpoint重新命名成fsimage；</li></ol><p>所以如果NameNode中的元数据丢失，是可以从Secondary NameNode恢复一部分元数据信息的，但不是全部，因为NaneNode正在写的edits日志还没有拷贝到Secondary NameNode，这部分恢复不了。</p><h4 id="十八-Secondary-NameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全？"><a href="#十八-Secondary-NameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全？" class="headerlink" title="十八 Secondary NameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全？"></a>十八 Secondary NameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全？</h4><p>这个问题就要说NameNode的高可用了，即NameNode HA。</p><p>一个NameNode有单点故障问题，那就配置两个NameNode，配置有两个关键点，一是必须要保证这两个NameNode的元数据信息必须要同步的，二是一个NameNode挂掉之后另一个要立马补上。</p><ol><li>元数据信息同步在HA方案中采用的是“共享存储”。每次写文件时，需要将日志同步写入共享存储，这个步骤成功才能认定写文件成功。然后备份节点定期从共享存储同步日志，以便进行主备切换。</li><li>监控NameNode状态采用zookeeper，两个NameNode节点的状态存放在zookeeper中，另外，两个NameNode节点分别有一个进程监控程序–ZKFC，实时读取zookeeper中NameNode的状态，来判断当前的NameNode是不是已经宕机。如果Standby的NameNode节点的ZKFC发现主节点已经挂掉，那么就会强制给原本的Active NameNode节点发送强制关闭请求，之后将Standby的NameNode设置为Active。</li></ol><h4 id="十九-在NameNode-HA中，会出现脑裂问题吗？怎么解决脑裂？"><a href="#十九-在NameNode-HA中，会出现脑裂问题吗？怎么解决脑裂？" class="headerlink" title="十九 在NameNode HA中，会出现脑裂问题吗？怎么解决脑裂？"></a>十九 在NameNode HA中，会出现脑裂问题吗？怎么解决脑裂？</h4><p>会出现脑裂问题：假设 NameNode1 当前为 Active 状态，NameNode2 当前为 Standby 状态。如果某一时刻 NameNode1 发生了“假死”现象（在进行垃圾回收时 和 网络延迟大时 可能发生），那么 Zookeeper 服务端会认为 NameNode1 挂掉了，根据前面的主备切换逻辑，NameNode2 会替代 NameNode1 进入 Active 状态。但是此时 NameNode1 可能仍然处于 Active 状态正常运行，这样 NameNode1 和 NameNode2 都处于 Active 状态，都可以对外提供服务。这种情况称为脑裂。</p><p>脑裂对于NameNode这类对数据一致性要求非常高的系统来说是灾难性的，数据会发生错乱且无法恢复。zookeeper社区对这种问题的解决方法叫做fencing（隔离），也就是想办法把旧是Active NameNode隔离起来，使它不能正常对外提供服务。</p><p>在进行fencing的时候，会执行以下操作：</p><ol><li>首先尝试调用这个旧Active NameNode的HAServiceProtocol RPC接口的transition ToStandby方法，看能不能把它转换为Standby状态。</li><li>如果失败，那么就执行Hadoop配置文件之中预定义的隔离措施，Hadoop目前主要提供两种隔离措施，通常会选择sshfence：<ol><li>sshfence：通过SSH登录到目标机器上，执行命令fuser将对应的进程杀死；</li><li>shellfence：执行一个用户自定义的shell脚本来将对应的进程隔离。</li></ol></li></ol><h4 id="二十-小文件过多会有什么危害，如何避免？"><a href="#二十-小文件过多会有什么危害，如何避免？" class="headerlink" title="二十 小文件过多会有什么危害，如何避免？"></a>二十 小文件过多会有什么危害，如何避免？</h4><p>Hadoop上大量HDFS元数据信息存储在NameNode内存中，因此过多的小文件必定会压垮NameNode的内存。</p><p>每个元数据对象约占50byte，所以如果有1千万个小文件，每个文件占用一个block，则NameNode大约需要2G空间。如果存储1亿个文件，则NameNode需要20G空间。</p><p>显而易见的解决这个问腿的方法就是合并小文件，可以选择在客户端上传时执行一定的策略先合并，或者是使用Hadoop的CombineFileInputFormat&lt;K,V&gt;实现小文件的合并。</p><h4 id="二十一-请说下HDFS的组织架构"><a href="#二十一-请说下HDFS的组织架构" class="headerlink" title="二十一 请说下HDFS的组织架构"></a>二十一 请说下HDFS的组织架构</h4><ol><li>Client：客户端<ol><li>切分文件。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行存储</li><li>与NameNode交互，获取文件的位置信息</li><li>与DataNode交互，读取或者写入数据</li><li>Client提供一些命令来管理HDFS，比如启动关闭HDFS、访问HDFS目录及内容（hdfs dfs -ls &#x2F;）等</li></ol></li><li>NameNode：名称节点，也称主节点，存储数据的元数据信息，不存储具体的数据<ol><li>管理HDFS的名称空间</li><li>管理数据块映射信息</li><li>配置副本策略</li><li>处理客户端读写请求</li></ol></li><li>DataNode：数据节点，也称从节点。NameNode下达命令，DataNode执行实际的操作<ol><li>存储实际的数据块</li><li>执行数据块的读&#x2F;写操作</li></ol></li><li>Secondary NameNode：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务<ol><li>辅助NameNode，分担其工作量</li><li>定期合并Fsimage和Edits，并推送给NameNode</li><li>在紧急情况下，可辅助恢复NameNode</li></ol></li></ol><h4 id="二十二-请说下MR中的Map-Task的工作机制"><a href="#二十二-请说下MR中的Map-Task的工作机制" class="headerlink" title="二十二 请说下MR中的Map Task的工作机制"></a>二十二 请说下MR中的Map Task的工作机制</h4><p>简单概述：</p><p>inputFile通过split被切割为多个split文件，通过Record按行读取内容给map（自己写的处理逻辑的方法），数据被map处理完之后，交给OutputCollect收集器，对其结果key进行分区（默认使用的hashPartitioner），然后写入buffer，每个map task都有一个内存缓冲区（环形缓冲区），存放着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式溢写到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task的拉取。</p><p>详细步骤：</p><ol><li>读取数据组件 InputFormat（默认 TextInputFormat）会通过 getSplits 方法对输入目录中的文件进行逻辑切片规划得到InputSplit，有多少个InputSplit就对应启动多少个map task</li><li>将输入文件切分为InputSplit之后，由RecordReader对象（默认是LineRecordReader）进行读取，以 \n 作为分隔符，读取一行数据，返回&lt;key,value&gt;，key表示每行首字符偏移量，value表示这一行文本内容</li><li>读取InputSplit返回&lt;key,value&gt;，进入用户自己继承的Mapper类中，执行用户重写的map函数，RecordReader读取一行这里调用一次</li><li>Mapper逻辑结束之后，将Mapper的每条结果通过 context.write进行collect数据收集。在collect中，会先对其进行分区处理，默认使用HashPartitioner</li><li>接下来，会将数据写入内存，内存中这片区域叫做环形缓冲区（默认100M），缓冲区的作用是批量收集Mapper结果，减少磁盘IO的影响。我们的key&#x2F;value键值对以及Partition的结果都会被写入缓冲区。当然，写入之前，key与value值都会被序列化成字节数组</li><li>当环形缓冲区的数据达到溢写比例（默认0.8），也就是80M时，溢写线程启动，需要对这80M空间内的数据做排序和合并。排序是MR模型默认的行为，这里的排序也是对序列化的字节做的排序</li><li>合并溢写文件，每次溢写会在磁盘上生成一个临时溢出文件（写之前判断是否有Combiner），如果Mapper的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个临时溢出文件存在。当整个数据处理结束之后开始对磁盘中的所有临时文件进行Merge归并、排序，因为最终的文件只有一个写入磁盘，并且为这个文件提供了一个索引文件，以记录每个reduce对应数据的偏移量</li></ol><h4 id="二十三-请说下MR中Reduce-Task的工作机制"><a href="#二十三-请说下MR中Reduce-Task的工作机制" class="headerlink" title="二十三 请说下MR中Reduce Task的工作机制"></a>二十三 请说下MR中Reduce Task的工作机制</h4><p>简单描述：</p><p>Reduce大致分为copy、sort、reduce三个阶段，重点在前两个阶段</p><p>copy阶段包含一个eventFetcher来获取已完成的map列表，由Fetcher线程去copy数据，在此过程中启动两个merge线程，分别为inMemoryMerger和onDiskMerger，分别将内存中的数据merge到磁盘和磁盘中是数据进行merge。待数据copy完成之后，copy阶段就完成了。</p><p>开始sort阶段，sort阶段主要是执行finalMerge操作，纯粹的sort阶段，完成之后就是reduce阶段，调用用户定义的reduce函数进行处理</p><p>详细步骤：</p><ol><li><p>Copy阶段：简单地拉取数据。Reduce进程启动一些数据copy线程（Fetcher），通过HTTP方式请求map task获取属于自己的文件（map task的分区会标识每个map task属于哪个reduce task，默认reduce task的标识从0开始）</p></li><li><p>Merge阶段：在远程拷贝数据的同时，Reduce Task启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘文件过多</p><p>merge有三种形式：内存到内存；内存到磁盘；磁盘到磁盘。默认情况下第一种形式不启用。当内存中的数据量到达一定阈值，就直接启动内存到磁盘的merge。与map端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。内存到磁盘的merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的文件</p></li><li><p>合并排序：把分散的数据合并成一个大的数据后，还会再对合并后的数据排序</p></li><li><p>对排序后的键值对调用reduce方法：键相等的键值对调用一次reduce方法，每次调用会产生零个或者多个键值对，最后把这些输出的键值对写入到HDFS文件中</p></li></ol><h4 id="二十四-请说下MR中的shuffle阶段"><a href="#二十四-请说下MR中的shuffle阶段" class="headerlink" title="二十四 请说下MR中的shuffle阶段"></a>二十四 请说下MR中的shuffle阶段</h4><p>shuffle阶段分为四个步骤：分区、排序、规约、分组，其中前三个步骤在map阶段完成，最后一个步骤在reduce阶段完成</p><p>shuffle是MR的核心，它分布在MR的map阶段和reduce阶段。一般把从map产生输出开始到reduce取得数据作为输入之前的过程称作shuffle</p><ol><li>Collect阶段：将Map Task的结果输出到默认为100M的环形缓冲区，保存的是key&#x2F;value，Partition分区信息等</li><li>Spill阶段：当内存中的数据量达到一定的阈值的时候，就会将数据写入本地磁盘，在将数据写入磁盘之前需要对数据进行一次排序的操作，如果配置了Combiner，还会将有相同分区号和key的数据进行排序</li><li>Map Task阶段的Merge：把所有溢出的临时文件进行一次合并操作，以确保一个Map Task最终只产生一个中间数据文件</li><li>Copy阶段：Reduce Task启动Fetcher线程到已完成Map Task的节点上复制一份属于自己的数据，这些数据默认会保存在内存的缓冲区中，当内存的缓冲区达到一定阈值的时候，就会将数据写到磁盘上</li><li>Reduce Task阶段的Merge：在Reduce Task远程复制数据的同时，会在后台开启两个线程对内存到本地的数据文件进行合并操作</li><li>Sort阶段：在对数据进行合并的同时，会进行排序操作，由于Map Task阶段已经对数据进行了局部的排序，Reduce Task只需保证copy的数据的最终整体有效性即可</li></ol><p>Shuffle中的缓冲区大小会影响到MR程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度越快。缓冲区的大小可以通过参数调整，参数：mapreduce.task.io.sort.mb 默认100M</p><h4 id="二十五-shuffle阶段的数据压缩机制了解吗？"><a href="#二十五-shuffle阶段的数据压缩机制了解吗？" class="headerlink" title="二十五 shuffle阶段的数据压缩机制了解吗？"></a>二十五 shuffle阶段的数据压缩机制了解吗？</h4><p>在shuffle阶段，可以看到数据通过大量拷贝，从map阶段输出的数据，都要通过网络拷贝，发送到reduce阶段，这一过程中，涉及到大量的网络IO，如果数据能够进行压缩，那么数据的发送量就会少很多</p><p>hadoop当中支持的压缩算法：gzip、bzip2、LZO、LZ4、Snappy，这几种压缩算法综合压缩和解压缩的速率，谷歌的Snappy是最优的，一般都选择Snappy压缩。</p><h4 id="二十六-在写MR时，什么情况下可以使用规约？"><a href="#二十六-在写MR时，什么情况下可以使用规约？" class="headerlink" title="二十六 在写MR时，什么情况下可以使用规约？"></a>二十六 在写MR时，什么情况下可以使用规约？</h4><p>规约（Combiner）是不能够影响任务的运行结果的局部汇总，适用于求和类，不适用于求平均值，如果reduce的输入参数类型和输出参数的类型是一样的，则规约的类可以使用reduce类，只需要在驱动类中指明规约的类即可</p><h4 id="二十七-YARN集群的架构和工作原理知道多少？"><a href="#二十七-YARN集群的架构和工作原理知道多少？" class="headerlink" title="二十七 YARN集群的架构和工作原理知道多少？"></a>二十七 YARN集群的架构和工作原理知道多少？</h4><p>YARN的基本设计思想是将MapReduce V1中的JobTracker拆分为两个独立的服务：ResourceManager和ApplicationMaster</p><p>ResourceManager负责整个系统的资源管理和分配，ApplicationMaster负责单个应用程序的管理</p><ol><li><p>ResourceManager：RM是一个全局的资源管理器，负责整个系统的资源管理和分配，它由两个部分组成：调度器（Scheduler）和应用程序管理器（Application Manager）</p><p>调度器根据容量、队列等限制条件，将系统中的资源分配给正在运行的应用程序，在保证容量、公平性和服务等级的前提下，优化集群资源利用率，让所有的资源都被充分利用。应用程序管理器负责管理整个系统中的所有的应用程序，包括应用程序的提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重启它。</p></li><li><p>ApplicationMaster：用户提交的一个应用程序会ApplicationMaster，它的主要功能有：</p><ol><li>与RM调度器协商以获得资源，资源以Container表示</li><li>将得到的任务进一步分配给内部的任务</li><li>与NM通信与启动&#x2F;停止任务</li><li>监控所有的内部任务状态，并在任务运行失败的时候重新为任务申请资源以重启任务</li></ol></li><li><p>NodeManager：NodeManager是每个节点上的资源和任务管理器，一方面，它会定期地向RM汇报本节点上的资源使用情况和各个Container的运行状态；另一方面，他接收并处理来自AM的Container启动和停止使用请求</p></li><li><p>Container：Container是YARN中的资源抽象，封装了各种资源。一个应用程序会分配一个Container，这个应用程序只能使用Container中描述的资源。不同于MapReduce V1中槽位solt的资源封装，Container是一个动态资源的划分单位，更能充分利用资源。</p></li></ol><blockquote><p>可以把YARN中的ResourceManager比作一个工程公司，其中调度器比作财务部，负责财务（资源）的管理；应用程序管理器比作研发部，负责管理研发任务；ApplicationMaster比作研发部门的小组，但是不是事先存在的，有任务才产生；NodeManager比作研发小组中的组员；Container比作给的钱。<br>当一个研发任务被客户提交给公司，研发部跟财务部协商，打第一份钱来组成研发小组，研发小组成立，如果还有足够余钱（因为组成这个小组会花钱，比如配电脑什么的），就直接分配任务和钱给组员。否则就向财务部申请money，再分配给组员。在这个过程中，组员会向小组汇报任务进程，小组会向研发部汇报进程。</p></blockquote><h4 id="二十八-YARN的任务提交流程是怎样的？"><a href="#二十八-YARN的任务提交流程是怎样的？" class="headerlink" title="二十八 YARN的任务提交流程是怎样的？"></a>二十八 YARN的任务提交流程是怎样的？</h4><p>当JobClient向YARN提交一个应用程序后，YARN将分两个阶段运行这个应用程序：一是启动ApplicationMaster；二是由ApplicationMaster创建应用程序，为它申请资源，监控运行直到结束。具体步骤如下：</p><ol><li>用户向YARN提交一个应用程序，并指定ApplicationMaster程序、启动ApplicationMaster、用户程序</li><li>RM为这个应用程序分配第一个Container，并与之对应的NM通讯，要求他在这个Container中启动应用程序ApplicationMaster</li><li>ApplicationMaster向RM注册，然后拆分为内部各个子任务，为各个内部任务申请资源，并监控这些任务的运行，直到结束</li><li>AM采用轮询的方式向RM申请和领取资源</li><li>RM为AM分配资源，以Container形式返回</li><li>AM申请到资源后，便与之对应的NM通讯，要求NM启动任务</li><li>NodeManager为任务设置好运行环境，将任务启动命令写到一个脚本中，并通过运行这个脚本启动任务</li><li>各个任务向AM汇报自己的状态和进度，以便当任务失败时可以重启任务</li><li>应用程序完成后，ApplicationMaster向ResourceManager注销并关闭自己</li></ol><h4 id="二十九-YARN的资源调度三种模型了解吗？"><a href="#二十九-YARN的资源调度三种模型了解吗？" class="headerlink" title="二十九 YARN的资源调度三种模型了解吗？"></a>二十九 YARN的资源调度三种模型了解吗？</h4><p>在YARN中有三种调度器可以选择：FIFO Scheduler、Capacity Scheduler、Fair Scheduler</p><p>Apache版本的hadoop默认使用的是Capacity Scheduler调度方式。CDH版本的默认使用的是Fair Scheduler调度方式</p><p>FIFO Scheduler（先来先服务）：</p><p>FIFO Scheduler把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用分配资源，待最头上的应用需求满足后再给下一个分配</p><p>FIFO Scheduler是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其他应用被阻塞。</p><p>Capacity Scheduler（能力调度器）：</p><p>对于Capacity调度器，有一个专门的队列用来运行小任务，但是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO Scheduler调度器时的时间</p><p>Fair Scheduler（公平调度器）：</p><p>在Fair调度器中，我们不需要预先占用一定的系统资源，Fair调度器会为所有的job动态的调整系统资源</p><p>比如：当第一个大job提交时，只有这一个job在运行，此时它获得了所有集群资源；当第二个小job提交后，Fair调度器会分配一半资源给这个小job，让这两个任务公平的共享集群资源</p><p>需要注意的是，在Fair调度器中，第二个任务从提交到获得资源会有一定延迟，因为它需要等待第一个任务释放占用的Container。小任务执行完成之后，也会释放自己占用的资源，大人物又获得了全部的系统资源。最终的效果就是Fair调度器即得到了高的资源利用率又能保证小任务及时完成。</p>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/hadoop/">hadoop</category>
      
      
      <comments>http://xuanyin02.github.io/2023/05169473.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于数据仓库hive知识的学习(2)</title>
      <link>http://xuanyin02.github.io/2023/05142227.html</link>
      <guid>http://xuanyin02.github.io/2023/05142227.html</guid>
      <pubDate>Sun, 14 May 2023 14:56:31 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;第6章-SQL快速掌握&quot;&gt;&lt;a href=&quot;#第6章-SQL快速掌握&quot; class=&quot;headerlink&quot; title=&quot;第6章 SQL快速掌握&quot;&gt;&lt;/a&gt;第6章 SQL快速掌握&lt;/h3&gt;&lt;h4 id=&quot;6-1-sql的运算模型-–-逐行运算模型&quot;&gt;&lt;a hre</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="第6章-SQL快速掌握"><a href="#第6章-SQL快速掌握" class="headerlink" title="第6章 SQL快速掌握"></a>第6章 SQL快速掌握</h3><h4 id="6-1-sql的运算模型-–-逐行运算模型"><a href="#6-1-sql的运算模型-–-逐行运算模型" class="headerlink" title="6.1 sql的运算模型 – 逐行运算模型"></a>6.1 sql的运算模型 – 逐行运算模型</h4><p>逐行运算：select后的运算表达式，是对每一行独立运算</p><p>表：一个数据的集合（集合中每一行就是一条数据：记录）</p><pre><code>select：    对一条数据的运算逻辑    -- 常量 :&quot;ok&quot; ,10 ,8.9    -- 变量 : id , name ,  age,    -- 运算符表达式：  age+10,  id+8 , id&gt;8  , id&gt;2 and id&lt;9    -- 函数表达式：  upper(name) , greatest(s1,s2,s3)     -- 复合表达式：  greatest(s1,s2,s3)&gt;2 , greatest(s1,s2,s3)+10 , lower(substr(upper(name),0,3))</code></pre><pre><code>from ：选择一个运算的数据集 </code></pre><pre><code>join：准备数据集（它可以将多个数据集拼成一个数据集，拼的时候可以带条件）join的拼接有多种方式：t1 join t2  --&gt; 笛卡尔积,结果的总行数的t1的行数*t2的行数；t1 join t2 on t1.id=t2.id  --&gt;内连接，满足拼接条件的才拼接..t1 left join t2 on t1.id=t2.id --&gt; 左（外）连接 left outer join ;左表所有行都保留，连接不上的右表字段为nullt1 right join t2 on t1.id=t2.id --&gt;右（外）连接 right outer join;右表的所有行都保留，连接不上的左表字段为nullt1 full join t2  on t1.id=t2.id --&gt;全（外）连接 full outer join;左、右表的行都保留，拼不上的字段为null-- hive不支持不等值join-- hive中有一种特别的join    left semi join  --&gt;左半连接，是sql中in子句的一个变种实现！    hive1.x中不支持in，现在的新版本hive支持in子句</code></pre><pre><code>where：逐行过滤将要运算的数据集,where执行在select之前   -- where id&gt;2   -- where (id+10)&gt;2   -- where upper(name) = &#39;ZHANGSAN&#39;   -- where id in (select id from t_x)</code></pre><pre><code>group by：函数：类似java代码中的方法，接收变量，返回结果，也就是一个表达式having：紧跟group by之后，是对分组后的数据进行按组过滤，将不满足条件表达式的组去除；</code></pre><h4 id="6-2-sql运算模型–分组聚合运算"><a href="#6-2-sql运算模型–分组聚合运算" class="headerlink" title="6.2 sql运算模型–分组聚合运算"></a>6.2 sql运算模型–分组聚合运算</h4><p>– 分组运算模型中，select后面的表达式只能有如下情形：</p><ol><li>常量</li><li>分组key</li><li>聚合函数</li></ol><p><strong>select语句中非分组函数的字段必须声明在GORUP BY中反之，GROUP BY中声明的字段可以不出现在select语句中</strong></p><p><strong>分组key可以有多个，分组key越多，分出来的组也会越多</strong></p><blockquote><p><em><strong>分组聚合还可以采用 partition by</strong></em></p></blockquote><h4 id="6-3-sql运算模型–开窗运算（窗口分析运算模型）"><a href="#6-3-sql运算模型–开窗运算（窗口分析运算模型）" class="headerlink" title="6.3 sql运算模型–开窗运算（窗口分析运算模型）"></a>6.3 sql运算模型–开窗运算（窗口分析运算模型）</h4><p>– 可以用窗口分析函数：row_number() over() 来实现</p><p>row_number() over(partition by sex order by salary desc) as rn</p><h3 id="第7章-HQL查询语法详解"><a href="#第7章-HQL查询语法详解" class="headerlink" title="第7章 HQL查询语法详解"></a>第7章 HQL查询语法详解</h3><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span><span class="token keyword">WITH</span> CommonTableExpression <span class="token punctuation">(</span><span class="token punctuation">,</span> CommonTableExpression<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">]</span>    <span class="token punctuation">(</span>Note: Only available starting <span class="token keyword">with</span> Hive <span class="token number">0.13</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> select_expr<span class="token punctuation">,</span> select_expr<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">FROM</span> table_reference  <span class="token punctuation">[</span><span class="token keyword">WHERE</span> where_condition<span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col_list<span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col_list<span class="token punctuation">]</span>  <span class="token punctuation">[</span>CLUSTER <span class="token keyword">BY</span> col_list    <span class="token operator">|</span> <span class="token punctuation">[</span>DISTRIBUTE <span class="token keyword">BY</span> col_list<span class="token punctuation">]</span> <span class="token punctuation">[</span>SORT <span class="token keyword">BY</span> col_list<span class="token punctuation">]</span>  <span class="token punctuation">]</span></code></pre><h4 id="7-1-with…as…临时表语法"><a href="#7-1-with…as…临时表语法" class="headerlink" title="7.1 with…as…临时表语法"></a>7.1 with…as…临时表语法</h4><blockquote><p>示例：</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">with</span> o <span class="token keyword">as</span> <span class="token punctuation">(</span><span class="token keyword">select</span>id<span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span>sale<span class="token punctuation">)</span> <span class="token keyword">as</span> amt<span class="token keyword">from</span> t_sale<span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> o <span class="token keyword">where</span> o<span class="token punctuation">.</span>amt<span class="token operator">></span><span class="token number">80</span><span class="token punctuation">;</span></code></pre><h4 id="7-2-排序"><a href="#7-2-排序" class="headerlink" title="7.2 排序"></a>7.2 排序</h4><h5 id="7-2-1-全局排序（Order-By）"><a href="#7-2-1-全局排序（Order-By）" class="headerlink" title="7.2.1 全局排序（Order By）"></a>7.2.1 全局排序（Order By）</h5><p>全局排序，强制只有一个reduce</p><h5 id="7-2-2-Sort-By"><a href="#7-2-2-Sort-By" class="headerlink" title="7.2.2 Sort By"></a>7.2.2 Sort By</h5><p>每个task内部进行排序，对全局结果集来说不是排序</p><p>要设置reduce个数：set mapreduce.job.reduces&#x3D;3;</p><p>当设置的reduce为1时，结果与Order By一样</p><h5 id="7-2-3-分桶排序1（Distribute-By-Sort-By）"><a href="#7-2-3-分桶排序1（Distribute-By-Sort-By）" class="headerlink" title="7.2.3 分桶排序1（Distribute By + Sort By）"></a>7.2.3 分桶排序1（Distribute By + Sort By）</h5><p>Distribute By：类似MR中partition，进行分区，可以结合sort by使用。<br>注意，Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前。<br>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p><p>示例：先按照部门编号分区，再按照员工编号降序排序</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> mapreduce<span class="token punctuation">.</span>job<span class="token punctuation">.</span>reduces<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp distribute <span class="token keyword">by</span> 部门编号 sort <span class="token keyword">by</span> 员工编号 <span class="token keyword">desc</span><span class="token punctuation">;</span></code></pre><h5 id="7-2-4-分桶排序2（Cluster-By）"><a href="#7-2-4-分桶排序2（Cluster-By）" class="headerlink" title="7.2.4 分桶排序2（Cluster By）"></a>7.2.4 分桶排序2（Cluster By）</h5><p>当distribute by和sorts by字段相同时，可以使用cluster by代替</p><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</p>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/hive/">hive</category>
      
      
      <comments>http://xuanyin02.github.io/2023/05142227.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于多功能引擎ES知识的学习</title>
      <link>http://xuanyin02.github.io/2023/051139179.html</link>
      <guid>http://xuanyin02.github.io/2023/051139179.html</guid>
      <pubDate>Thu, 11 May 2023 01:57:47 GMT</pubDate>
      
      <description>介绍了分布式全文搜索引擎ES的知识</description>
      
      
      
      <content:encoded><![CDATA[<p>想必大家都知道ES，一款非常好用的工具，但是我还是想详细解释一下它的概念：ES全称Elasticsearch，是一个<strong>开源的高扩展的分布式全文搜索引擎</strong>，是整个Elastic Stack技术栈的核心。它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。可以看出ES功能非常强大，所以现在国内外很多公司都在使用。</p><p>看到这里又会有人说了：传统数据库不行吗？还真不行（也不是不行，就是效果不好），哈哈哈哈。传统数据库实现全文检索的话很鸡肋，因为一般不会用传统数据库存非结构化的像文本字段等数据。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于insert和update操作都会重新构建索引。基于以上原因可以分析得出，在一些生产环境中，使用常规的搜索方式，性能是非常差的：</p><ul><li>搜索的数据对象是大量的非结构化的文本数据</li><li>文件记录量达到数十万或数百万个甚至更多</li><li>支持大量基于交互式文本的查询</li><li>需求非常灵活的全文搜索查询</li><li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足</li><li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况</li></ul><p>为了解决这些问题，我们就需要<strong>全文搜索引擎</strong>，它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户。这个过程类似于通过字典中的检索字表查字的过程。</p><h3 id="首先我们来讲讲-ES-入门知识"><a href="#首先我们来讲讲-ES-入门知识" class="headerlink" title="首先我们来讲讲 ES 入门知识"></a>首先我们来讲讲 ES 入门知识</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521151302269.png" alt="image-20230521151302269"><figcaption>image-20230521151302269</figcaption></figure></p><blockquote><p>Elasticsearch 7.X 中, Type 的概念已经被删除</p></blockquote><h4 id="HTTP操作"><a href="#HTTP操作" class="headerlink" title="HTTP操作"></a>HTTP操作</h4><h5 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h5><h6 id="1）创建索引"><a href="#1）创建索引" class="headerlink" title="1）创建索引"></a>1）创建索引</h6><p>向 ES 服务器发 <strong>PUT</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521151518186.png" alt="image-20230521151518186"><figcaption>image-20230521151518186</figcaption></figure></p><h6 id="2）查看所有索引"><a href="#2）查看所有索引" class="headerlink" title="2）查看所有索引"></a>2）查看所有索引</h6><p>向 ES 服务器发 <strong>GET</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/_cat/indices?v">http://127.0.0.1:9200/_cat/indices?v <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521151602723.png" alt="image-20230521151602723"><figcaption>image-20230521151602723</figcaption></figure></p><h6 id="3）查看单个索引"><a href="#3）查看单个索引" class="headerlink" title="3）查看单个索引"></a>3）查看单个索引</h6><p>向 ES 服务器发 <strong>GET</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521151654728.png" alt="image-20230521151654728"><figcaption>image-20230521151654728</figcaption></figure></p><h6 id="4）删除索引"><a href="#4）删除索引" class="headerlink" title="4）删除索引"></a>4）删除索引</h6><p>向 ES 服务器发 <strong>DELETE</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521151727176.png" alt="image-20230521151727176"><figcaption>image-20230521151727176</figcaption></figure></p><h5 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h5><h6 id="1）创建文档"><a href="#1）创建文档" class="headerlink" title="1）创建文档"></a>1）创建文档</h6><p>向 ES 服务器发 <strong>POST</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_doc">http://127.0.0.1:9200/shopping/_doc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为:</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"小米手机"</span><span class="token punctuation">,</span><span class="token property">"category"</span><span class="token operator">:</span><span class="token string">"小米"</span><span class="token punctuation">,</span><span class="token property">"images"</span><span class="token operator">:</span><span class="token string">"http://www.gulixueyuan.com/xm.jpg"</span><span class="token punctuation">,</span><span class="token property">"price"</span><span class="token operator">:</span><span class="token number">3999.00</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521152238668.png" alt="image-20230521152238668"><figcaption>image-20230521152238668</figcaption></figure></p><p>上面的数据创建后，由于没有指定数据唯一性标识（ID），默认情况下，ES 服务器会随机生成一个。</p><p>如果想要自定义唯一性标识，需要在创建时指定：<a class="link" href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h6 id="2）查看文档"><a href="#2）查看文档" class="headerlink" title="2）查看文档"></a>2）查看文档</h6><p>向 ES 服务器发 <strong>GET</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h6 id="3）修改文档"><a href="#3）修改文档" class="headerlink" title="3）修改文档"></a>3）修改文档</h6><p>向 ES 服务器发 <strong>POST</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为：</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"华为手机"</span><span class="token punctuation">,</span><span class="token property">"category"</span><span class="token operator">:</span><span class="token string">"华为"</span><span class="token punctuation">,</span><span class="token property">"images"</span><span class="token operator">:</span><span class="token string">"http://www.gulixueyuan.com/hw.jpg"</span><span class="token punctuation">,</span><span class="token property">"price"</span><span class="token operator">:</span><span class="token number">4999.00</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h6 id="4）修改字段"><a href="#4）修改字段" class="headerlink" title="4）修改字段"></a>4）修改字段</h6><p>向 ES 服务器发 <strong>POST</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_update/1">http://127.0.0.1:9200/shopping/_update/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为:</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"doc"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"price"</span><span class="token operator">:</span><span class="token number">3000.00</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h6 id="5）删除文档"><a href="#5）删除文档" class="headerlink" title="5）删除文档"></a>5）删除文档</h6><blockquote><p>删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）</p></blockquote><p>向 ES 服务器发 <strong>DELETE</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h6 id="6）条件删除文档"><a href="#6）条件删除文档" class="headerlink" title="6）条件删除文档"></a>6）条件删除文档</h6><p>向 ES 服务器发 <strong>POST</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/shopping/_delete_by_query">http://127.0.0.1:9200/shopping/_delete_by_query <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为:</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"query"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"match"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"price"</span><span class="token operator">:</span><span class="token number">4000.00</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h5><p>有了索引库，等于有了数据库中的 database。接下来就需要创建索引库(index)中的映射了，类似于数据库(database)中的表结构(table)。创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。</p><h6 id="1）创建映射"><a href="#1）创建映射" class="headerlink" title="1）创建映射"></a>1）创建映射</h6><p>向 ES 服务器发 <strong>PUT</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/student/_mapping">http://127.0.0.1:9200/student/_mapping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为：</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"name"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>            <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"sex"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>            <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"age"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>            <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>映射数据说明：</p><ul><li><p>字段名：任意填写，下面指定许多属性，例如：title、subtitle、images、price</p><p>​type：类型，Elasticsearch 中支持的数据类型非常丰富，说几个关键的：</p><p>​String 类型，又分两种：</p><p>​text：可分词<br>keyword：不可分词，数据会作为完整字段进行匹配</p><p>​Numerical：数值类型，分两类</p><p>​基本数据类型：long、integer、short、byte、double、float、half_float</p><p>​浮点数的高精度类型：scaled_float</p><p>​Date：日期类型</p><p>​Array：数组类型</p><p>​Object：对象</p></li><li><p>index：是否索引，默认为 true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>​true：字段会被索引，则可以用来进行搜索</p><p>​false：字段不会被索引，不能用来搜索</p></li><li><p>store：是否将数据进行独立存储，默认为 false</p><p>​原始的文本会存储在_source 里面，默认情况下其他提取出来的字段都不是独立存储的，是从_source 里面提取出来的。当然你也可以独立的存储某个字段，只要设置”store”: true 即可，获取独立存储的字段要比从_source 中解析快得多，但是也会占用更多的空间，所以要根据实际业务需求来设置。</p></li><li><p>analyzer：分词器，这里的 ik_max_word 即使用 ik 分词器,后面会有专门的章节学习</p></li></ul><h6 id="2）查看映射"><a href="#2）查看映射" class="headerlink" title="2）查看映射"></a>2）查看映射</h6><p>向 ES 服务器发 <strong>GET</strong> 请求 ：<a class="link" href="http://127.0.0.1:9200/student/_mapping">http://127.0.0.1:9200/student/_mapping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h6 id="3）索引映射关联"><a href="#3）索引映射关联" class="headerlink" title="3）索引映射关联"></a>3）索引映射关联</h6><p>向 ES 服务器发 PUT 请求 ：<a class="link" href="http://127.0.0.1:9200/student1">http://127.0.0.1:9200/student1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>请求体内容为：</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"settings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"properties"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"name"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">true</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"sex"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"age"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><h3 id="然后再说说-ES-进阶知识"><a href="#然后再说说-ES-进阶知识" class="headerlink" title="然后再说说 ES 进阶知识"></a>然后再说说 ES 进阶知识</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li><p>索引（Index）</p><p>一个索引就是一个拥有几份相似特征的文档的集合。一个索引由一个名字来标识（<strong>必须全部是小写字母</strong>），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p><p>能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。</p><blockquote><p><strong>Elasticsearch  索引的精髓：一切设计都是为了提高搜索的性能</strong></p></blockquote></li><li><p>类型（Type）</p><p>一个类型是你的索引的一个逻辑上的分类&#x2F;分区。ElasticSearch 7.x 默认不再支持自定义索引类型（默认类型为：_doc）。</p></li><li><p>文档（Document）</p><p>一个文档是一个可被索引的基础信息单元，也就是一条数据。文档以 JSON 格式来表示，而 JSON 是一个<br>到处存在的互联网数据交互格式。</p></li><li><p>字段（Field）</p><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p></li><li><p>映射（Mapping）</p></li><li><p>分片（Shards）</p><p>被混淆的概念是，一个 Lucene  索引  我们在 Elasticsearch  称作  分片  。  一个 Elasticsearch  索引  是分片的集合。  当 Elasticsearch  在索引中搜索的时候，  他发送查询到每一个属于索引的分片(Lucene  索引) ，然后合并每个分片的结果到一个全局的结果集</p></li><li><p>副本（Replicas）</p></li><li><p>分配（Allocation）</p><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p></li></ul><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521163302271.png" alt="image-20230521163302271"><figcaption>image-20230521163302271</figcaption></figure></p><p>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。</p><p>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 <strong>每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点</strong>。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p><h4 id="路由计算"><a href="#路由计算" class="headerlink" title="路由计算"></a>路由计算</h4><p>当索引一个文档的时候，文档会被存储到一个主分片中。Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？</p><p>通过路由计算我们就能知道以上答案</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521163737067.png" alt="image-20230521163737067"><figcaption>image-20230521163737067</figcaption></figure></p><blockquote><p><strong>routing 默认是文档的_id，也可以设置成自定义值。number_of_primary_shards 是主分片的数量</strong></p></blockquote><h4 id="分片控制"><a href="#分片控制" class="headerlink" title="分片控制"></a>分片控制</h4><p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node1，我们将其称为<strong>协调节点</strong>(coordinating node) 。</p><blockquote><p>当发送请求的时候，为了扩展负载，更好的做法是轮询集群中所有的节点</p></blockquote><h5 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h5><p>新建、索引和删除请求都是<strong>写</strong>操作， <strong>必须在主分片上面完成之后才能被复制到相关的副本分片</strong></p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521164742537.png" alt="image-20230521164742537"><figcaption>image-20230521164742537</figcaption></figure></p><ol><li>客户端向Node1发送新建、索引或者删除请求</li><li>节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node3，因为分片 0 的主分片目前被分配在 Node3 上</li><li>Node3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node1 和 Node2的副本分片上。一旦所有的副本分片都报告成功, Node3 将向协调节点报告成功，协调节点向客户端报告成功</li></ol><h5 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h5><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521164935969.png" alt="image-20230521164935969"><figcaption>image-20230521164935969</figcaption></figure></p><ol><li>客户端向 Node1 发送获取请求</li><li>节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node2 </li><li>Node2 将文档返回给 Node1，然后将文档返回给客户端</li></ol><h5 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h5><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521165313434.png" alt="image-20230521165313434"><figcaption>image-20230521165313434</figcaption></figure></p><ol><li>客户端向 Node1 发送更新请求</li><li>它将请求转发到主分片所在的 Node3</li><li>Node3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃</li><li>如果 Node3 成功地更新文档，它将<strong>完整的新版本的文档</strong>并行转发到 Node1 和 Node2 上的副本分片，重新建立索引。一旦所有副本分片都返回成功， Node3 向协调节点也返回成功，协调节点向客户端返回成功</li></ol><h4 id="分片原理"><a href="#分片原理" class="headerlink" title="分片原理"></a>分片原理</h4><p>分片是 Elasticsearch 最小的工作单元。但是究竟什么是一个分片，它是如何工作的？</p><p>文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值<br>需求的数据结构是<strong>倒排索引</strong></p><h5 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h5><p>首先来看看什么是正向索引</p><p><strong>正向索引</strong>，就是搜索引擎会将待搜索的文件都对应一个文件 ID，搜索时将这个ID 和搜索关键字进行对应，形成 K-V 对，然后对关键字进行统计计数</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521175100274.png" alt="image-20230521175100274"><figcaption>image-20230521175100274</figcaption></figure></p><p>但是搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回结果要求，所以搜索引擎会将正向索引重新构建为倒排索引</p><p><strong>倒排索引</strong>，即把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521175237157.png" alt="image-20230521175237157"><figcaption>image-20230521175237157</figcaption></figure></p><p>分词和标准化的过程称为<strong>分析</strong></p><blockquote><p>倒排索引被写入磁盘后是不可改变的:它永远不会修改</p></blockquote><p>不变性有重要的价值：</p><ul><li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题</li><li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升</li><li>其它缓存(像 filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化</li><li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I&#x2F;O 和 需要被缓存到内存的索引的使用量</li></ul><h5 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h5><p>如何在保留不变性的前提下实现倒排索引的更新？</p><p><strong>更新方案</strong>：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到，从最早的开始查询完后再对结果进行合并。</p><h5 id="按段搜索"><a href="#按段搜索" class="headerlink" title="按段搜索"></a>按段搜索</h5><p>按段搜索会以如下流程执行：</p><ol><li><p>新文档被收集到内存索引缓存</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521184530401.png" alt="image-20230521184530401"><figcaption>image-20230521184530401</figcaption></figure></p></li><li><p>不时地, 缓存被提交</p><p>(1) 一个新的段–一个追加的倒排索引—被写入磁盘。<br>(2) 一个新的包含新段名字的 提交点 被写入磁盘<br>(3) 磁盘进行 同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件</p></li><li><p>新的段被开启，让它包含的文档可见以被搜索</p></li><li><p>内存缓存被清空，等待接收新的文档</p><p><figure class="image-caption"><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/xuanyin02/ImgHosting/article_img/image-20230521184659247.png" alt="image-20230521184659247"><figcaption>image-20230521184659247</figcaption></figure></p></li></ol><h3 id="最后聊一下如何对-ES-进行优化"><a href="#最后聊一下如何对-ES-进行优化" class="headerlink" title="最后聊一下如何对 ES 进行优化"></a>最后聊一下如何对 ES 进行优化</h3><h4 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h4><ul><li>使用SSD。固态硬盘比机械硬盘优秀很多</li><li>使用 RAID 0。条带化 RAID 会提高磁盘 I&#x2F;O，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验 RAID 因为副本已经提供了这个功能</li><li>另外，使用多块硬盘，并允许 Elasticsearch 通过多个 path.data 目录配置把数据条带化分配到它们上面</li><li>不要使用远程挂载的存储，比如 NFS 或者 SMB&#x2F;CIFS。这个引入的延迟对性能来说完全是背道而驰的</li></ul><h4 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h4>]]></content:encoded>
      
      
      <category domain="http://xuanyin02.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
      
      
      <category domain="http://xuanyin02.github.io/tags/es/">es</category>
      
      
      <comments>http://xuanyin02.github.io/2023/051139179.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
